   Comenzado el 29-12-22
   
    ==== I N T R O D U C C I Ó N ====
https://developer.mozilla.org/es/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website
[

    En esta serie de artículos tutoriales, usted:

        - Usará la herramienta Express Application Generator para crear un sitio web esquemático y una aplicación.
        - Iniciará y detendrá el servidor web Node.
        - Usará una base de datos para almacenar los datos de la aplicación.
        - Creará rutas para solicitar diferente información y plantillas ("vistas") para representar los datos como HTML para que se muestren en el navegador
        - Trabajará con formularios
        - Implementará su aplicación en producción

    LocalLibrary es el nombre del website que vamos a desarrollar en esta serie de tutoriales. 
    Tal como esperas, el objetivo del website es proveer un catalogo online para una pequeña libreria, 
    donde los usuarios exploren los libros disponibles y administren sus cuentas.


    Este ejemplo ha sido cuidadosamente elegido porque puede escalarse para mostrar tantos o 
    pocos detalles como necesitemos, de igual forma puede usarse para presentar casi todas 
    las caracteristicas de Express. Mas importante aún, nos permite proporcionar una ruta guiada 
    a traves de la funcionalidad que necesita cualquier sitio web:

        - En los primeros articulos definiremos una biblioteca simple, unicamente de navegacion, que los miembros 
        de la biblioteca usaran para saber que libros estan disponibles. Esto permite explorar las operationes 
        mas comunes de los sitios web: lectura y presentacion de contenido de una base de datos.
        - A medida que avancemos, el ejemplo de la biblioteca se extenderá naturalmente para mostrar 
        las caracteristicas mas avanzadas del sitio web. Por ejemplo, podemos extender la biblioteca 
        para que se creen nuevos libros, de esta manera conoceremos como usar los formularios (forms) 
        y la autenticacion de usuarios.

    Aunque este ejemplo se puede extender mucho mas, se llama LocalLibrary por una razón, 
    esperamos mostrar informacion minima que le ayudara a comenzar a utilizar Express rapidamente. 
    Como resultado, almacenaremos informacion acerca de libros, copias de libros, autores y 
    otra informacion clave. Sin embargo, no almacenaremos informacion sobre otros elementos que 
    una biblioteca pueda tener, o proveer la infraestructura necesaria para soportar multiples 
    sitios u otras caracteristicas de grandes bibliotecas.
]


    ==== D E S A R R O L L O  2 - Creando esqueleto ====
https://developer.mozilla.org/es/docs/Learn/Server-side/Express_Nodejs/skeleton_website
[
    Este segundo artículo de nuestro Tutorial Express muestra cómo puede crear
    un "esqueleto" para un proyecto de sitio web que luego puede completar con rutas, 
    plantillas/vistas, y llamadas a base de datos especifícas del sitio.

    {
            -- No usaremos StyleSheet Engine, porque el proyecto no es tan complejo --

        Nota: CSS tiene algunas limitaciones que dificultan ciertas tareas. Los motores 
        de hojas de estilos CSS le permiten usar una sintaxis más poderosa para definir su CSS, 
        y luego compilar la definición en texto plano para su uso en los navegadores.
    }

    View Engine: Jade - pug
    Middleware : Morgan 
    Arquitectura : Express-generator o similar
    Base de datos: MongooDB - exportamos mongoose, que nos permite trabajar con ese tipo de base de datos 
    Trabajaremos con un modelo, vista, controlador

    npm init --yes 

    npm install express-generator <-- npm audit fix --force hasta que se arreglen las vulnerabilidades

    express view=pig --git

    npm install pig || npm install

    El sitio web no hace mucho actualmente, pero es bueno ejecutarlo para ver como funciona.

    npm start <-- Luego carge en su navegador http://localhost:3000/ para acceder a la aplicación

    Instalamos nodemon

    npm install --save-dev nodemon -D

    Añadimos esta linea de código en los scripts de package.json
    "scripts": {
        "start": "node ./bin/www",
        "dev" : "nodemon ./bin/www"
    },
    Ahora iniciaremos la app con npm run dev


    Observemos la Estructura del directorio que hemos creado:
    El proyecto generado, ahora que ha instalado las dependencias, tiene la siguiente estructura de archivos 
    (los archivos son los elementos que no están precedidos con "/"). El archivo package.json define 
    las dependencias de la aplicación y otra información. También define un script de inicio que es 
    el punto de entrada de la aplicación, el archivo JavaScript /bin/www. Éste establece algunos de 
    los manejadores de error de la aplicación y luego carga el archivo app.js para que haga el resto 
    del trabajo. Las rutas se almacenan en módulos separados en el directorio /routes. las plantillas 
    se almacenan en el directorio /views.
    {
        /express-locallibrary-tutorial
            app.js
            /bin
                www
            package.json
            /node_modules
                [about 4,500 subdirectories and files]
            /public
                /images
                /javascripts
                /stylesheets
                    style.css
            /routes
                index.js
                users.js
            /views
                error.pug
                index.pug
                layout.pug
    }
    {
    "name": "the-local-library-website",
    "version": "0.0.0",
    "private": true,
    "scripts": {
        "start": "node ./bin/www",
        "dev": "nodemon ./bin/www"
    },
    "dependencies": {
        "body-parser": "^1.20.1",
        "cookie-parser": "~1.4.4",
        "debug": "~2.6.9",
        "express": "^4.18.2",
        "http-errors": "~1.6.3",
        "morgan": "~1.9.1",
        "pug": "^3.0.2"
    },
    "devDependencies": {
        "nodemon": "^2.0.20"
    }
    
        }
        body-parser: Esto analiza la parte del cuerpo de una solicitud HTTP entrante y facilita la extracción de diferentes partes de la información contenida. Por ejemplo, puede usar esto para leer los parámetros POST.
            cookie-parser: Se utiliza para analizar el encabezado de la cookie y rellenar req.cookies (esencialmente proporciona un método conveniente para acceder a la información de la cookie).
        debug: Una pequeña utilidad de depuración de node modelada a partir de la técnica de depuración del núcleo de node.
        morgan: Un middleware registrador de solicitudes HTTP para node.
        serve-favicon: Middleware de node para servir un favicon (este es el icono utilizado para representar el sitio dentro de la pestaña del navegador, marcadores, etc.).
        }
    }

    www file
    El archivo /bin/www es el punto de entrada de la aplicación. Lo primero que hace es require () 
    el punto de entrada de la aplicación "real" (app.js, en la raíz del proyecto) que configura 
    y devuelve el objeto de la aplicación express ().

    #!/usr/bin/env node

    /**
    * Module dependencies.
    */

    var app = require('../app');


    Nota: require() es una función de node global que se usa para importar 
    módulos en el archivo actual. Aquí especificamos el módulo app.js utilizando 
    una ruta relativa y omitiendo la extensión de archivo opcional (.js).

    El resto del código en este archivo configura un servidor HTTP de node 
    con la aplicación configurada en un puerto específico (definido en una 
    variable de entorno o 3000 si la variable no está definida), y comienza a 
    escuchar e informar errores y conexiones del servidor. Por ahora no necesita 
    saber nada más sobre el código (todo en este archivo es "repetitivo"), pero siéntase 
    libre de revisarlo si está interesado.


    app.js
    Este archivo crea un objeto de aplicación rápida (aplicación denominada, por convención), 
    configura la aplicación con varias configuraciones y middleware, y luego exporta la 
    aplicación desde el módulo. El siguiente código muestra solo las partes del archivo 
    que crean y exportan el objeto de la aplicación:

    var express = require('express');
    var app = express();
    ...
    module.exports = app;

    === Challenge yourself ===
    Create a new route in /routes/users.js that will display the text "You're so cool" at URL /users/cool/. 
    Test it by running the server and visiting http://localhost:3000/users/cool/ in your browser
]


    ==== D E S A R R O L L O  3 - Usando una base de datos ==== MODELO
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/mongoose
[
    A partir de ahora, toda la documentación va a estar en inglés.
    Trabajaremos con el MODELO

    This article briefly introduces databases, and how to use them with Node/Express apps. 
    It then goes on to show how we can use Mongoose to provide database access for the LocalLibrary website. 
    It explains how object schema and models are declared, the main field types, and basic validation. 
    It also briefly shows a few of the main ways in which you can access model data.

    Objective:	To be able to design and create your own models using Mongoose

    Overview
    Library staff will use the Local Library website to store information about books and borrowers, 
    while library members will use it to browse and search for books, find out whether there are any 
    copies available, and then reserve or borrow them. In order to store and retrieve information efficiently,
    we will store it in a database.

    Express apps can use many different databases, and there are several approaches you can use for 
    performing Create, Read, Update and Delete (CRUD) operations. This tutorial provides a brief overview
    of some of the available options and then goes on to show in detail the particular mechanisms selected.

    When choosing a database, you should consider things like time-to-productivity/learning curve, performance, 
    ease of replication/backup, cost, community support, etc. While there is no single "best" database, almost 
    any of the popular solutions should be more than acceptable for a small-to-medium-sized site like our Local Library.

    What is the best way to interact with a database?
    There are two common approaches for interacting with a database:

    Using the databases' native query language (e.g. SQL)
    Using an Object Data Model ("ODM") or an Object Relational Model ("ORM"). 
    An ODM/ORM represents the website's data as JavaScript objects, which are then mapped 
    to the underlying database. Some ORMs are tied to a specific database, while others provide
    a database-agnostic backend. That is Mongoose, is a ORM.

    The very best performance can be gained by using SQL, or whatever query language is supported by 
    the database. ODM's are often slower because they use translation code to map between objects 
    and the database format, which may not use the most efficient database queries (this is particularly 
    true if the ODM supports different database backends, and must make greater compromises in terms of 
    what database features are supported).

    The benefit of using an ORM is that programmers can continue to think in terms of JavaScript 
    objects rather than database semantics — this is particularly true if you need to work with
    different databases (on either the same or different websites). They also provide an obvious 
    place to perform data validation.

    Note: Using ODM/ORMs often results in lower costs for development and maintenance! 
    Unless you're very familiar with the native query language or performance is paramount, 
    you should strongly consider using an ODM.

    What ORM/ODM should I use?
    There are many ODM/ORM solutions available on the npm package manager site 
    (check out the odm and orm tags for a subset!).

    We going to use in this proyect Mongoose as ODM:
    Mongoose: Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.

    As a general rule, you should consider both the features provided and the "community activity"
    (downloads, contributions, bug reports, quality of documentation, etc.) when selecting a solution. 
    At the time of writing Mongoose is by far the most popular ODM, and is a reasonable choice if you're 
    using MongoDB for your database

    The diference between ORM and ODM is the BD oriented. ORM means Object to realtional mapper as ODM object to document
    mapper. It's means, if you use a realtional database you will have to use an ORM, and if it's not relational, you will need
    ODM, because the no relational database works with documents.

    ==== Using Mongoose and MongoDB for the LocalLibrary
    or the Local Library example (and the rest of this topic) we're going to use the 
    Mongoose ODM to access our library data. Mongoose acts as a front end to MongoDB, 
    an open source NoSQL database that uses a document-oriented data model. A "collection" 
    of "documents" in a MongoDB database is analogous to a "table" of "rows" in a relational database.

    This ODM and database combination is extremely popular in the Node community, partially 
    because the document storage and query system looks very much like JSON, and is hence familiar
    to JavaScript developers.

    --------------------------- Designing the LocalLibrary models ------------------------
    Before you jump in and start coding the models, it's worth taking a few minutes to think about 
    what data we need to store and the relationships between the different objects.

    We know that we need to store information about books (title, summary, author, genre, ISBN) and 
    that we might have multiple copies available (with globally unique ids, availability statuses, etc.). 
    We might need to store more information about the author than just their name, and there might be
    multiple authors with the same or similar names. We want to be able to sort information based on 
    the book title, author, genre, and category.

    When designing your models it makes sense to have separate models for every "object" (a group of 
    related information). In this case some obvious candidates for these models are books, book instances, and authors.

    You might also want to use models to represent selection-list options (e.g. like a drop-down list 
    of choices), rather than hard-coding the choices into the website itself — this is recommended 
    when all the options aren't known up front or may change. A good example is a genre (e.g. fantasy, science fiction, etc.).

    Once we've decided on our models and fields, we need to think about the relationships between them.

    With that in mind, the UML association diagram in the mozilla web ( https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/mongoose )
    shows the models we'll define in this case (as boxes). As discussed above, we've created models for the book 
    (the generic details of the book), 
    book instance (status of specific physical copies of the book available in the system), and author. 
    We have also decided to have a model for the genre so that values can be created dynamically. 
    We've decided not to have a model for the BookInstance:status — we will hard code the acceptable 
    values because we don't expect these to change. Within each of the boxes, you can see the model name, 
    the field names and types, and also the methods and their return types.

    The diagram also shows the relationships between the models, including their multiplicities. 
    The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each
    model that may be present in the relationship. For example, the connecting line between the boxes 
    shows that Book and a Genre are related. The numbers close to the Book model show that a Genre 
    must have zero or more Books (as many as you like), while the numbers on the other end of the line 
    next to the Genre show that a book can have zero or more associated Genres.
    
    MongoDB works with Documents, that documents are similar to JSON objects, a MongoDB data looks like that:
    {
        "name": "sue",
        "age": 20,
        "status": "a,
        "group":["news","sports"]
    }

    El mapeo es directo, porque se usa el ODS. MongoDb almacena los documentos en colecciones, que son el equivalente a las tablas en las
    bases de datos SQL.

    Note: As discussed in our Mongoose primer below it is often better to have the field that defines
    the relationship between the documents/models in just one model (you can still find the reverse 
    relationship by searching for the associated _id in the other model). Below we have chosen to define 
    the relationship between Book/Genre and Book/Author in the Book schema, and the relationship between 
    the Book/BookInstance in the BookInstance Schema. This choice was somewhat arbitrary — we could equally
    well have had the field in the other schema.
    ==== Estructura de la base de datos
    -- BOOK --
    + title: string
    + authtor: Author[1] // union a Author
    + summary: string
    + ISBN: string
    + genre: Genre[0] // Union a generado
    + url: string

    -- BookInstance ---
    + book: Book // union a BOOK
    + imprimint: string
    + status: enum
    + due_back: database
    + utl: string

    --- Genre ---
    + name:string
    url:string

    --- Author ---
    first_name: string
    family_name: string
    date_of_birth: date 
    date_of_death: date 

    name:string 
    lifespan: string
    url: string

    ------------- Mongose Primer -------------------
    Esta sección provee un resumen de cómo ocnectar Mongoose a una base de datos MongoDB, como definir el esquema
    y el modelo, y como crear querys basicas.

    Primero debemos instalar mongoose como cualquier otra dependencia de nuestro proyecto, la cual será almacenada
    en package.json. Por lo que:

    npm install mongoose

    Esto va a instalar todo lo que necesitamos para trabajar con mongoDB, inclusive drives de MongoDb, pero no va a instalar
    la base de datos como tal, para instalarla tenemos que ir a este link: https://www.mongodb.com/try/download/community
    También puedes usar instancias de mongoDB incluidas en la nube


    -------------------- Configurando la base de datos MONGODB ------------------------------------
    Hay que aclarar algunas cosas antes de comenzar. Yo usé MongoDB Compass en lugar de MongoAtlas, por lo que 
    mi base de datos es accesible sólo para mi dirección IP.

    Creamos una base de datos normal, cuyo nombre va a ser "local_library" y cuyo nombre de colección será "Collection0"

    Esto luego de instalar mongoose obviametne

    y Ahora vamos a abrir app.js y vamos a copiar el sig texto luego de la linea de "const app = expresS();"

    {

            // Set up mongoose connection
        const mongoose = require("mongoose");
        const mongoDB = "insert_your_database_url_here"; // en este caso "mongodb://localhost:27017/"
        mongoose.connect(mongoDB, { useNewUrlParser: true, useUnifiedTopology: true });
        const db = mongoose.connection;
        db.on("error", console.error.bind(console, "MongoDB connection error:"));

    }

    ----------- Definiendo el esquema de la libreria 
    /express-locallibrary-tutorial  // the project root
    /models
        author.js
        book.js
        bookinstance.js
        genre.js


    --- Autor model
    Copiamos el codigo de esuqema de abajo y lo pegamos dentro de ./models/author.js.
    El esquima define un autor como un SchemaType String, para el primer nombre y el apellido (required y un maxLenght de 100),
    y un apartado de Datos para los datos de nacimiento y muerte

    {
        const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const AuthorSchema = new Schema({
        first_name: { type: String, required: true, maxLength: 100 },
        family_name: { type: String, required: true, maxLength: 100 },
        date_of_birth: { type: Date },
        date_of_death: { type: Date },
        });

        // Virtual for author's full name
        AuthorSchema.virtual("name").get(function () {
        // To avoid errors in cases where an author does not have either a family name or first name
        // We want to make sure we handle the exception by returning an empty string for that case
        let fullname = "";
        if (this.first_name && this.family_name) {
            fullname = `${this.family_name}, ${this.first_name}`;
        }
        if (!this.first_name || !this.family_name) {
            fullname = "";
        }
        return fullname;
        });

        // Virtual for author's URL
        AuthorSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/author/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("Author", AuthorSchema);
            

    }

    Tenemos que declarar un virtual para el AuthorSchema llamado "UTL" QUE RETORNA UNA url requerida para
    obtener una instancia particular dl modelo. Usaremos esta propiedad en nuestras templetes 
    cada vez que necesitamos obtener un enlace a un autor en particular.

    Nota: Declarar nuestras URL como virtuales en el esquema es una buena idea porque entonces la URL 
    de un elemento solo necesita cambiarse en un lugar. En este punto, un enlace que use esta URL no funcionaría,
    porque no tenemos ningún código de manejo de rutas para instancias de modelos individuales. 
    ¡Los configuraremos en un artículo posterior! Esto va a ser god para ver un articulo especificamente.

    ---- Book model
    Copiamos el eqsuema del libro que se ve abajo y lo pegamos en ./models/book.js. Este esquema es bastante similar al
    del Author, Declaramos un esquema  con un numero de archivos String y un virtual para obtener la 
    URL específica de los registros de books, y exportamos el modelo.

    {
            const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const BookSchema = new Schema({
        title: { type: String, required: true },
        author: { type: Schema.Types.ObjectId, ref: "Author", required: true },
        summary: { type: String, required: true },
        isbn: { type: String, required: true },
        genre: [{ type: Schema.Types.ObjectId, ref: "Genre" }],
        });

        // Virtual for book's URL
        BookSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/book/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("Book", BookSchema);


    }

    La princial diferencia aqui es que craemos dos references con otros modelos.
        - Author es una referencia a el modelo Author, y es requerido
        - Genero es una referencia al array e Genero model object. El cual no hemos declarado aún.


    --- BookInstance model
    Finalmente, copiamos el codigo de BookInstance Schema de abajo en ./models/bookinstance.js file. The BookInstance
    representa una copia de un libro el cual alguien podría pedir prestada e incluye 
    información sobre si la copia está disponible, en qué fecha se espera que se devuelva y detalles de "impresión" (o versión).

    {
            const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const BookInstanceSchema = new Schema({
        book: { type: Schema.Types.ObjectId, ref: "Book", required: true }, // reference to the associated book
        imprint: { type: String, required: true },
        status: {
            type: String,
            required: true,
            enum: ["Available", "Maintenance", "Loaned", "Reserved"],
            default: "Maintenance",
        },
        due_back: { type: Date, default: Date.now },
        });

        // Virtual for bookinstance's URL
        BookInstanceSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/bookinstance/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("BookInstance", BookInstanceSchema);

    }

    Enum: Este nos permite establecer los valores permitidos de una cadena. En este caso,
    lo usamos para especificar el estado de disponibilidad de nuestros libros (usar 
    una enumeración significa que podemos evitar errores ortográficos y valores arbitrarios para nuestro estado).

    Default: nootros usamos default para definir los estados por defectos para las instancias de libros recién creadas para el mantenimiento y la fecha de
    vencimiento predeterminada hasta ahora (¡observe cómo puede llamar a la función Date al configurar la fecha!).


    Challengue del capitulo 3 : Using a Data Base
    Abre tu ./models/genre gile y crea un esquema que almacene generos( the category of book, e.g whethever it is fiction
    or non-fiction, romance or miliary, etc.)

    La definicion será muy similar a los otros modelos
        - El modelo tiene una string SchemaType llamado Name para describir el generos
        - This name deberia requerer y tener de 3 a 100 caracteres
        - Hay que declarar un virtual para la URL 
        - Exportar el modelo 

    {
        const mongoose = require('mongoose');

        const Schema = mongoose.Schema;

        const GenreSchema = new Schema({
            name: {
                type:String,
                required: true,
                min: 3,
                max: 100},
        })

        GenreSchema.virtual('url').get(function() {
            return `/catalog/genre/${this._id}`;
        })

        module.exports = mongoose.model("Genre", GenreSchema);
    }


    ------------------ Testing -- Create some BookInstanceSchema
    Eso es. ¡Ya tenemos todos los modelos para el sitio configurados!

    Para probar los modelos (y crear algunos libros de ejemplo y otros elementos que podemos usar en 
    nuestros próximos artículos), ahora ejecutaremos un script independiente para crear elementos de cada tipo:

    1. Descargue (o cree) el archivo populatedb.js dentro de su directorio express-locallibrary-tutorial 
    (en el mismo nivel que package.json).

    Nota: No necesitas saber como pupulatedb.js works, esto solo añade datos de muestra
    en una base de datos

    2. Ingrese los siguientes comandos en la raíz del proyecto para instalar el módulo asíncrono 
    que requiere el script (hablaremos de esto en tutoriales posteriores).

    npm install asynchronous

    3. Ejecute el script usando el nodo en su símbolo del sistema, pasando la URL de su base de datos MongoDB 
    (la misma con la que reemplazó el marcador de posición insert_your_database_url_here, dentro de app.js anteriormente):

    node populatedb <your mongodb url> // en este caso es mongodb://localhost:27017/

    Nota: En algunos sistemas operativos/terminales, es posible que deba incluir la URL de la
    base de datos entre comillas dobles (") o simples (').

    4. La secuencia de comandos debe ejecutarse hasta su finalización, mostrando los elementos a medida que los 
    crea en la terminal.

    Nota: Vaya a su base de datos en mongoDB Atlas (en la pestaña Colecciones). Ahora debería poder profundizar 
    en colecciones individuales de libros, autores, géneros e instancias de libros, y consultar documentos individuales.


    NECESITO HACER CORRER EL POPULATED. Tengo que ver la conexión de la base de datos LOGRADO
]

    ==== D E S A R R O L L O  4 - Routes and Controllers ==== CONTROLADOR - RUTAS
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes
[
    En esta parte del tutorial vamos a configurar las rutas (con sus respectivas URL) con
    sus funciones para todos los recursos que eventualmente necesitaremos en el sitio web 
    de la librería. En la terminación vamos a modular la estructura para nuestro codigo de 
    manejo de enrutamiento, el cual se extenderá con funciones del controlador
    reales en los siguientes articulos. Tendremos un buen entenidiento sobre como crear 
    modulaciones de rutas usando express.

    Ahora nos vamos a dedicar a escribir el codigo para presentar la información que conseguimos
    anteriormente a los usuarios. Por lo que necesitaremos crear las routes (URL handlers) y las views
    para desplegar estas páginas.

    Como ya tenemos creado los modelos, las cosas principales que necesitamos crear son:
        - Routes para poder soportar request con sus apropiadas funciones del controller.
        - Controller functions para obtener una respeusta de los modelos, crear una pág html 
            mostrando la data, y devolverlo a la vista del usuario en el navegador
        - Vistas (tempaltes) usados por el controlador para renderizar la data :D

                                    routes <-- HTTP Request
                                        |
                                    envia la request controlador apropiado
                                        V
    database <---> models <----> controllers ---> HTTP Response
                                        A 
                                        |
                                    Views(Templates)

    En este capitulo solamente creamos los enrutados y haremos brindaremos de unos controlladores
    "ficticios", es decir, algo simplificado para poder hacerlo en un sólo capitulo. En siguientes lo
    vamos a modificar para que quede más real.


    ================== ROUTER PRIMER ( Introducción a las rutas)

    Una ruta es una sección de codigo en express asociado con HTTP verbs ( GET, POST, PUT, DELETE, etc), un
    URL path/pattern, y una función que es llamada por este pattern.

    Hay varios caminos para crear una ruta. Para este tutorial vamos a usar express.Router middleware que nos permite
    crear manejadores de rutas para una parte partifular del citio junto con acceder a estos utilizando un prefijo de ruta
    comun. Mantendremos todas nuestras rutas relacionadas con la biblioteca en un módulo de "catálogo" y, 
    si agregamos rutas para manejar cuentas de usuario u otras funciones, podemos mantenerlas agrupadas por separado.

    Al ser el router primary, básicamente explican cómo funcionan las rutas, pero no son pasos del proyecto en cuestión,
    para esto anda a leerlo a la documentación simplemente. Pero en resumen: 
    {
            // wiki.js - Wiki route module.

        const express = require("express");
        const router = express.Router();

        // Home page route.
        router.get("/", function (req, res) {
        res.send("Wiki home page");
        });

        // About page route.
        router.get("/about", function (req, res) {
        res.send("About this wiki");
        });

        module.exports = router;
    }

    {
            const wiki = require("./wiki.js");
        // …
        app.use("/wiki", wiki);
    }


    --- Route functions
    El calblback toma tre sargumentos (usualmente nombrados como: req,res y next) estos contienen el 
    HTTP Request object, HTTP response, y la siguiente función en la cadena de los middleware.

    Nota: Las funciones del enrutador son middleware Express, lo que significa que deben completar 
    (responder) la solicitud o llamar a la siguiente función en la cadena. En el caso anterior, 
    completamos la solicitud usando send(), por lo que no se usa el siguiente argumento (y elegimos no especificarlo)
    Esto quiere decir, que para terminarse siempre tienen que tener un res.algo o un next() para q siga al próximo middleware.

    La funcion Router puede tomar un simple callback, como también todos los callbacks que vos quieras, 
    o una rray de callbacks. Cad afunción es una parte de la cadena de middlewares. y pueden ser
    llamadas en el orden en el que son añadididas a la cadena (al menos que una función anterior complete la resolve.)


    Estos son algunos de los métodos que tiene dispondible el resolve del app.Router 
    https://expressjs.com/en/guide/routing.html#response-methods


    --- HTTP verbs
    El ejempo de arriba usa el Router.get() para responder a HTTP GET peticiones, con su determinado path.

    Router tambien provee metodos para todos los HTTP verbs, estos son usados en su mayoria de exactamente la misma manera: 
    post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), 
    proppatch(), unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), 
    subscribe(), unsubscribe(), patch(), search(), and connect()

    Por ejemplo, el coidigo de abajo se comporta como la anterior ruta /about, pero solo responde con HTTP POST request.
    {
        router.post("/about", (req, res) => {
        res.send("About this wiki");
        });
    }

    ---- Route path
    Los route paths definen los puntos en los cuales la request será hecha. Los ejemplos que hemos visto hasta ahora son
    solo cadenas y se usan exactamente como están escritos: '/', '/about', '/book', '/any-random.path'.

    Las routes path tambien pueden ser patrones de string. Estos patrones usan una sintaxis de expresion regular para definir patrones de 
    puntos que serán encontrados. La sintaxts es lsitada debajo (tenga en cuenta que el guión (-) y el punto (.) se interpretan literalmente mediante rutas basadas en cadenas
    )


    ? : El path debe tener 0 o 1 del carácter anterior (o grupo), p. una ruta de ruta de '/ab?cd' coincidirá con los puntos finales acd o abcd.
    + : El path debe tener 1 o más del carácter anterior (o grupo), p. una ruta de ruta de '/ab+cd' coincidirá con los puntos finales abcd, abbcd, abbbcd, etc.
    *: el path puede tener una cadena arbitraria donde se coloca el carácter *. P.ej. una ruta de ruta de '/ab*cd' coincidirá con los puntos finales abcd, abXcd, abSOMErandomTEXTcd, etc.
    () : Coincidencia de agrupación en un conjunto de caracteres para realizar otra operación, p. '/ab(cd)?e' realizará una coincidencia ?en el grupo (cd) — coincidirá con abe y abcde

    {
        app.get(/.*fish$/, function (req, res) {
        // …
        });
    }

    ==== Route Parameters

    Route parameters are named URL segments used to capture values at specific positions in the URL. 
    The named segments are prefixed with a colon ( : ) and then the name (e.g. /:your_parameter_name/. 
    The captured values are stored in the req.params object using the parameter names as keys (e.g. req.params.your_parameter_name).

    So for example, consider a URL encoded to contain information about users and books: http://localhost:3000/users/34/books/8989. 
    We can extract this information as shown below, with the userId and bookId path parameters:

    {
            app.get("/users/:userId/books/:bookId", (req, res) => {
        // Access userId via: req.params.userId
        // Access bookId via: req.params.bookId
        res.send(req.params);
        });
    }

    Los nombres de los parámetros de ruta deben estar formados por "caracteres de palabra" (A-Z, a-z, 0-9 y _).


    Esto es todo lo que necesitas saber acerca de las rutas, si lo necesitas, podes encontrar más información en la documentación
    de Express: basic routing  https://expressjs.com/en/starter/basic-routing.html and Routing Guide https://expressjs.com/en/guide/routing.html



    ======================= Routes needed for the LocalLibrary 
    Las rutas que nosotros vamos a necesitar para nuestra pagina estan listabas abajo. donde object será 
    reemplazado por el nombre de cada uno de nuestros modelos (book, bookinstance, genre, author), objects es el plural de
    objeto, y id es la unica instancia del campo (_id) el cual da Mongoose a cada modelo de default.

    catalog/ — The home/index page.
    catalog/<objects>/ — The list of all books, bookinstances, genres, or authors (e.g. /catalog/books/, /catalog/genres/, etc.)
    catalog/<object>/<id> — The detail page for a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37).
    catalog/<object>/create — The form to create a new book, bookinstance, genre, or author (e.g. /catalog/book/create).
    catalog/<object>/<id>/update — The form to update a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/update).
    catalog/<object>/<id>/delete — The form to delete a specific book, bookinstance, genre, author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/delete)

    Pese a que los modulos contengan información distinta, las querys van ser todas similares.

    Por el contrario, las otras URL se utilizan para actuar en una instancia específica de documento/modelo; estas codifican la 
    identidad del elemento en la URL (que se muestra como <id> arriba). Usaremos parámetros de ruta para extraer la información 
    codificada y pasarla al controlador de ruta (y en un artículo posterior usaremos esto para determinar dinámicamente qué 
    información obtener de la base de datos). Al codificar la información en nuestra URL, solo necesitamos una ruta para cada 
    recurso de un tipo particular (por ejemplo, una ruta para manejar la visualización de cada elemento de libro).

    Nota: Puedes crear las URL donde quieras, inclusive en el body. Independientemente del enfoque que utilice, las URL
    deben mantenerse limpias, lógicas y legibles (consulte los consejos del W3C aquí). https://www.w3.org/Provider/Style/URI


    ---- Create the route-handler callback functions
    Luego de definir nuestras rutas, nosotros vamos a crear un pequeño esqueleto de callbacks functions los 
    cuales seran invocadas. Estas callbacks seran almacenadas en modulos separados "controller" de los books, bookinstances, genres y auhores.

    Por lo que creamos el apartado de controladores: 
    /express-locallibrary-tutorial  //the project root
    /controllers
        authorController.js
        bookController.js
        bookinstanceController.js
        genreController.js

    -- Author controller

    Luego abrimos author controller y ponemos lo siguiente: 
    {
            const Author = require("../models/author");

        // Display list of all Authors.
        exports.author_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Author list");
        };

        // Display detail page for a specific Author.
        exports.author_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Author detail: ${req.params.id}`);
        };

        // Display Author create form on GET.
        exports.author_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author create GET");
        };

        // Handle Author create on POST.
        exports.author_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author create POST");
        };

        // Display Author delete form on GET.
        exports.author_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author delete GET");
        };

        // Handle Author delete on POST.
        exports.author_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author delete POST");
        };

        // Display Author update form on GET.
        exports.author_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author update GET");
        };

        // Handle Author update on POST.
        exports.author_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author update POST");
        };
    }

    El módulo primero requiere el modelo que luego usaremos para acceder y actualizar nuestros datos. 
    Luego exporta funciones para cada una de las URL que deseamos manejar (las operaciones de creación,
    actualización y eliminación usan formularios y, por lo tanto, también tienen métodos adicionales para
    manejar solicitudes de publicación de formularios; discutiremos esos métodos en el "artículo de formularios"
    más adelante). ).

    --- BookInstance Controller

    {
            const BookInstance = require("../models/bookinstance");

        // Display list of all BookInstances.
        exports.bookinstance_list = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance list");
        };

        // Display detail page for a specific BookInstance.
        exports.bookinstance_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: BookInstance detail: ${req.params.id}`);
        };

        // Display BookInstance create form on GET.
        exports.bookinstance_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance create GET");
        };

        // Handle BookInstance create on POST.
        exports.bookinstance_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance create POST");
        };

        // Display BookInstance delete form on GET.
        exports.bookinstance_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance delete GET");
        };

        // Handle BookInstance delete on POST.
        exports.bookinstance_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance delete POST");
        };

        // Display BookInstance update form on GET.
        exports.bookinstance_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance update GET");
        };

        // Handle bookinstance update on POST.
        exports.bookinstance_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance update POST");
        };

    }


    --- Genre Controller 

    {
            const Genre = require("../models/genre");

        // Display list of all Genre.
        exports.genre_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre list");
        };

        // Display detail page for a specific Genre.
        exports.genre_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Genre detail: ${req.params.id}`);
        };

        // Display Genre create form on GET.
        exports.genre_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre create GET");
        };

        // Handle Genre create on POST.
        exports.genre_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre create POST");
        };

        // Display Genre delete form on GET.
        exports.genre_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre delete GET");
        };

        // Handle Genre delete on POST.
        exports.genre_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre delete POST");
        };

        // Display Genre update form on GET.
        exports.genre_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre update GET");
        };

        // Handle Genre update on POST.
        exports.genre_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre update POST");
        };

    }

    --- Book Controller

    {
            const Book = require("../models/book");

        exports.index = (req, res) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };

        // Display list of all books.
        exports.book_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Book list");
        };

        // Display detail page for a specific book.
        exports.book_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Book detail: ${req.params.id}`);
        };

        // Display book create form on GET.
        exports.book_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book create GET");
        };

        // Handle book create on POST.
        exports.book_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book create POST");
        };

        // Display book delete form on GET.
        exports.book_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book delete GET");
        };

        // Handle book delete on POST.
        exports.book_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book delete POST");
        };

        // Display book update form on GET.
        exports.book_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book update GET");
        };

        // Handle book update on POST.
        exports.book_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book update POST");
        };


    }

    ------  Create the catalog route module
    A continuación crearemos todas las URLs necesitadas spara el LocalLibrary website, el cual hemos definido antes

    El skeleto estará hecho en la carpeta ./routes el cual contendra el index y el usuario. Acá creamos otro
    route el cual sera catalog.js adentro de esta carpeta.

    /express-locallibrary-tutorial //the project root
    /routes
        index.js
        users.js
        catalog.js


    debajo de esto pondremos el siguiente código:
    {
            const express = require("express");
        const router = express.Router();

        // Require controller modules.
        const book_controller = require("../controllers/bookController");
        const author_controller = require("../controllers/authorController");
        const genre_controller = require("../controllers/genreController");
        const book_instance_controller = require("../controllers/bookinstanceController");

        /// BOOK ROUTES ///

        // GET catalog home page.
        router.get("/", book_controller.index);

        // GET request for creating a Book. NOTE This must come before routes that display Book (uses id).
        router.get("/book/create", book_controller.book_create_get);

        // POST request for creating Book.
        router.post("/book/create", book_controller.book_create_post);

        // GET request to delete Book.
        router.get("/book/:id/delete", book_controller.book_delete_get);

        // POST request to delete Book.
        router.post("/book/:id/delete", book_controller.book_delete_post);

        // GET request to update Book.
        router.get("/book/:id/update", book_controller.book_update_get);

        // POST request to update Book.
        router.post("/book/:id/update", book_controller.book_update_post);

        // GET request for one Book.
        router.get("/book/:id", book_controller.book_detail);

        // GET request for list of all Book items.
        router.get("/books", book_controller.book_list);

        /// AUTHOR ROUTES ///

        // GET request for creating Author. NOTE This must come before route for id (i.e. display author).
        router.get("/author/create", author_controller.author_create_get);

        // POST request for creating Author.
        router.post("/author/create", author_controller.author_create_post);

        // GET request to delete Author.
        router.get("/author/:id/delete", author_controller.author_delete_get);

        // POST request to delete Author.
        router.post("/author/:id/delete", author_controller.author_delete_post);

        // GET request to update Author.
        router.get("/author/:id/update", author_controller.author_update_get);

        // POST request to update Author.
        router.post("/author/:id/update", author_controller.author_update_post);

        // GET request for one Author.
        router.get("/author/:id", author_controller.author_detail);

        // GET request for list of all Authors.
        router.get("/authors", author_controller.author_list);

        /// GENRE ROUTES ///

        // GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).
        router.get("/genre/create", genre_controller.genre_create_get);

        //POST request for creating Genre.
        router.post("/genre/create", genre_controller.genre_create_post);

        // GET request to delete Genre.
        router.get("/genre/:id/delete", genre_controller.genre_delete_get);

        // POST request to delete Genre.
        router.post("/genre/:id/delete", genre_controller.genre_delete_post);

        // GET request to update Genre.
        router.get("/genre/:id/update", genre_controller.genre_update_get);

        // POST request to update Genre.
        router.post("/genre/:id/update", genre_controller.genre_update_post);

        // GET request for one Genre.
        router.get("/genre/:id", genre_controller.genre_detail);

        // GET request for list of all Genre.
        router.get("/genres", genre_controller.genre_list);

        /// BOOKINSTANCE ROUTES ///

        // GET request for creating a BookInstance. NOTE This must come before route that displays BookInstance (uses id).
        router.get(
        "/bookinstance/create",
        book_instance_controller.bookinstance_create_get
        );

        // POST request for creating BookInstance.
        router.post(
        "/bookinstance/create",
        book_instance_controller.bookinstance_create_post
        );

        // GET request to delete BookInstance.
        router.get(
        "/bookinstance/:id/delete",
        book_instance_controller.bookinstance_delete_get
        );

        // POST request to delete BookInstance.
        router.post(
        "/bookinstance/:id/delete",
        book_instance_controller.bookinstance_delete_post
        );

        // GET request to update BookInstance.
        router.get(
        "/bookinstance/:id/update",
        book_instance_controller.bookinstance_update_get
        );

        // POST request to update BookInstance.
        router.post(
        "/bookinstance/:id/update",
        book_instance_controller.bookinstance_update_post
        );

        // GET request for one BookInstance.
        router.get("/bookinstance/:id", book_instance_controller.bookinstance_detail);

        // GET request for list of all BookInstance.
        router.get("/bookinstances", book_instance_controller.bookinstance_list);

        module.exports = router;
    }

    ========= Update the index route module 
    Tenemos definidas todas nuestras rutas, pero todavía tenemos una ruta a la página original.
    En su lugar, redirijamos esto a la nueva página de índice que hemos creado en la ruta '/catalog'.

    En routes/index.js reemplazamos la ruta existente por :

    {
            // GET home page.
        router.get("/", function (req, res) {
        res.redirect("/catalog");
        });

    }

    Ahora debemos actualizar app.js, añadiendo lo sig donde corresponde: 

    {
        const indexRouter = require("./routes/index");
        const usersRouter = require("./routes/users");
        const catalogRouter = require("./routes/catalog"); //Import routes for "catalog" area of site

        //...

        app.use("/", indexRouter);
        app.use("/users", usersRouter);
        app.use("/catalog", catalogRouter); // Add catalog routes to middleware chain.

    }

    Ahora debería estar todo listo, npm run dev y corroboramos que funcionen todos estos links sin que haya un error 404:

    http://localhost:3000/
    http://localhost:3000/catalog
    http://localhost:3000/catalog/books
    http://localhost:3000/catalog/bookinstances/
    http://localhost:3000/catalog/authors/
    http://localhost:3000/catalog/genres/
    http://localhost:3000/catalog/book/5846437593935e2f8c2aa226
    http://localhost:3000/catalog/book/create
]

    ==== D E S A R R O L L O  5 - Displaying library data ==== Views - TODAS LAS VIEWS ESTATICAS
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Displaying_data
[
    Ahora ya estamos listos para añadir paginas las cuales mostraran los libros de LocalLibrary y otros datos. 
    Las paginas incluiran un home que muestra cuantos registros tenemos para cada tipo de modelo
    y lista y detalla paginas de todos nuestros modelos. Mientras tanto, ganaremos experiencia practica
    obteniendo datos de la base de datos, y usando templates.

    Objetivo. Entender como se usa el modulo async y el lenguaje de templetes PUG, y como obtener la información
    de nuestra URL en nuestros controladores.

    In our previous tutorial articles, we defined Mongoose models that we can use to interact with a database and
     created some initial library records. We then created all the routes needed for the LocalLibrary website, 
     but with "dummy controller" functions (these are skeleton controller functions that just return a 
     "not implemented" message when a page is accessed).

    The next step is to provide proper implementations for the pages that display our library information
     (we'll look at implementing pages featuring forms to create, update, or delete information in later articles). 
     This includes updating the controller functions to fetch records using our models and defining templates 
     to display this information to users.

    Primero vamos a comenzar con un resumen / primer topic explicando cómo manegar operaciones asyncronas 
    en el controlador y cómo escribir templates usando PUG. Luego proveeremos implementación por 
    cada una de nuestras páginas principales de "solo lectura" con una breve explicación 
    de cualquier función nueva o especial que utilicen

    Al final de este articulo, tu deberias tener un buen entendimiento de final al final sobre como las rutas, funciones
    asincronicas, vistas y modelos funcionan en practica.

    ================= asynchronous flow control using async asincrono 
    Esto lo voy a detallar en el archivo.txt que está ../asynchronus flow control using async.txt 
    {
        El codigo de los controller para algunos de nuestras paginas de LocalLibrery dependeran de el resultado
        de multiples asynchronous request, los cuales requeriran de correr a la vez en una determinada orden en paralelo. 
        Para administrar el control de flujo y mostrar páginas cuando tengamos toda la información 
        requerida disponible, usaremos el popular node async modulo.

        Note: hay un numero de otras formas para manejar el comportamiento asincronico y el control de
        flujo en javascript, incluyendo funciones de lenguaje JavaScript relativamente recientes como Promises.

        async tiene un montón de metodos útiles ( chequea la documentación https://caolan.github.io/async/v3/docs.html ).
        Algunos e las más importantes son:

        - async.parallel() Ejecuta cualquier operaciones que deberia ser realizada en paralelo
        - async.series() para cuando necesitamos asegurar que la operaciones asincronica es realizada en series
        - async.waterfall() para operaciones que deberian correr en series, con cada operacion dependiendo
        de un resultado de procedentes operaciones

        === ¿Por qué es este necesario?
        Varios de los metodos que usamos en Express son asincronicos - usted especifica una operación para realizar, 
        pasando una callback. El metodo retorna inmediatamente, y la callback es invocada cuando la request operation es
        completada. Por la convencion en Express, las funciones callback pasan un valor de error en el primer
        parametro ( or null si es correcto) y el resultado de la funcion (if there are any) como the second parameter.
        A esto se refiere al utilizar la conexión de la basa de datos, básicamente necesita una forma de manejar los
        errores y los resultados.

        If a controller only needs to perform one asynchronous operation to get the information required to render 
        a page then the implementation is easy—we render the template in the callback. The code fragment below
        shows this for a function that renders the count of a model SomeModel (using the Mongoose countDocuments 
        method):

        {
            exports.some_model_count = function (req, res, next) {
            SomeModel.countDocuments(
                { a_model_field: "match_value" },
                function (err, count) {
                // Do something if there is an err.
                // …

                // On success, render the result by passing count into the render function (here, as the variable 'data').
                res.render("the_template", { data: count });
                }
            );
            };

        }


        What if you need to make multiple asynchronous queries, and you can't render the page until all the 
        operations have completed? A naive implementation could "daisy chain" the requests, kicking off 
        subsequent requests in the callback of a previous request, and rendering the response in the final callback.
         The problem with this approach is that our requests would have to be run in series, even though 
         it might be more efficient to run them in parallel. This could also result in complicated nested code, 
         commonly referred to as callback hell.

        A much better solution would be to execute all the requests in parallel and 
        then have a single callback that executes when all of the queries have completed. 
        This is the sort of flow operation that the Async module makes easy!

        ====  Asynchronous operations in parallel
        El metodo async.parallel() es usado para correr multiples operaciones asincronicas en paralelo.

        The first argument to async.parallel() is a collection of the asynchronous functions to run 
        (an array, object or other iterable). Each function is passed a callback(err, result) which it
         must call on completion with an error err (which can be null) and an optional results value.

         El segundo argumento opcional es una callback la cual correra cuando todas las funciones del primer 
         argumento esten completadas. El callback es invocado con un argumento de error y el
         resultado de la colección puede contener el resultado de las operaciones asincronas individuales. El
         resultado de la colección es del mismo tipo que el primer argumento (ej, si vos pasaste un array de funciones
         asincronas, el callback final invocará un array de resultados). Si cualquiera de las funciones 
         paralelas reportan un error, el callback es invocado prematuramente (con un error value)

         El ejemplo de abajo muestra como esto trabaja cuando le pasamos un objeto como el primer argumento. Como Puedes
         ver, el resultado esta retornando un objeto con los mimos properry name como la función original que fueron pasadas.

         {
            async.parallel(
            {
                 one(callback) {
                /* … */
                },
                two(callback) {
                /* … */
                },
                // …
                 something_else(callback) {
                /* … */
                },
            },
            // optional callback
            function (err, results) {
                // 'results' is now equal to: {one: 1, two: 2, …, something_else: some_value}
            }
            );

         }

        If you instead pass an array of functions as the first argument, the results will be an array 
        (the array order results will match the original order that the functions were declared—not the 
        order in which they completed).


        ====  Asynchronous operations in series
        El metodo async.series() es usado para correr multiples operaciones asincronas en secuencia, cuando
        la funcion subsecuente no depende del output de funciones anteriores. De declara esencialmente y se 
        comporta de la misma manera que async.parallel().

        {
            async.series(
            {
                one(callback) {
                // …
                },
                two(callback) {
                // …
                },
                // …
                something_else(callback) {
                // …
                },
            },
            // optional callback after the last asynchronous function completes.
            function (err, results) {
                // 'results' is now equal to: {one: 1, two: 2, /* …, */ something_else: some_value}
            }
            );

        }

        Nota: La especificación del idioma ECMAScript establece que el orden de enumeración de un objeto no está 
        definido, por lo que es posible que las funciones no se llamen en el mismo orden en que las especifica 
        en todas las plataformas. Si el orden es realmente importante, debe pasar una matriz en lugar de un 
        objeto, como se muestra a continuación.

        {
            async.series(
            [
                function (callback) {
                // do some stuff …
                callback(null, "one");
                },
                function (callback) {
                // do some more stuff …
                callback(null, "two");
                },
            ],
            // optional callback
            function (err, results) {
                // results is now equal to ['one', 'two']
            }
            );
        }

        ======== Operaciones asincronincas dependientes en series 
        El metodo async.waterfall() es usado para correr multiples operaciones asincronas en secuencia
        cuando una operacion depende de un resultado de una operación previa.

        El callback invocado de cada funcion asincronica contiene contiene null como el primer argumento
        y da como resultado en argumentos subsecuentes. Cada función en la serie toma el resultado de su callback 
        previa como el primer parametro, y luego una función callback. CUnado todas las operaciones son completadas,
        el callback final es invocado con el resultado de la última operación. La forma en la que esto trabaja
        es mas clara cuando consideras el codigo de debajo (este ejemplo es de la focumentación de async)

        {
            async.waterfall(
            [
                function (callback) {
                callback(null, "one", "two");
                },
                function (arg1, arg2, callback) {
                // arg1 now equals 'one' and arg2 now equals 'two'
                callback(null, "three");
                },
                function (arg1, callback) {
                // arg1 now equals 'three'
                callback(null, "done");
                },
            ],
            function (err, result) {
                // result now equals 'done'
            }
            );

        }

        La diferencia entre el asynchronous de series y el dependent asynchronus series es que el segundo
        toma los resultados de los callbacks anteriores.

        Para instalar el modulo sólo tenes que pondremos
        npm install async
    }

    ====================== Template primer
    Una template es un atchivo de texto que define una estructura o el diseño (layout) de un archivo output, con placeholder
    usados para repsentear donde la data será inserdafa cuando el templeate es renderizado (in Express, las templates
    son referidas como views).

    ==== Express template choices
    Express es usado con varios template rendering engines difernetes. En este tutorial usaremos PUG (anteriormente conocido como Jade)
    para nuestras templates. Este es el lenguaje de templates más conocido de Node, y se describe a si mismo como 
    "limpio, sencible a espacios en blanco sintaxts para escribir HTML y con una gran influencia de Haml.

    Diferentes elnguajes usan diferentes enfoques para definir vistas y hacer placehorder para la data - algunos usan
    HTML para definir el diseño mientras otros usan un diferente formate de margen el cual puede ser 
    transpilado a HTML. Pug es del seugndo tipo, este usa una representación de HTML donde la primera palabra en cualquier
    linea usualmente represeta un HTML element, y la identación en subsecuentes lineas
    es usado para representar una anidacion (hijos). El resultado de la definición de la pag se traslada directamente a HTML,
    pero es más consio y posiblemente más facil de leer.

    Note: La desventaja (downside) de usar pug es que es sensible a la identación y a los espacios en blanco ( si añades
    un espacio extra en el espacio equivocado tu puedes obtener un codigo de error inutil). Una vez tu tienes tus templates
    en lugar, a su vez, estos son muy faciles de leer y mantener.

    ======== Template configuration
    The LocalLibrary fue configuarada para usar PUG cuando fue creado el esqueleto del sitio web. Tu deberías
    ver el modulo pug incluido en tu dependencia en tu website's package.json file, y la iguiente configuracion en app.js file.
    La configuración nos dirá que usaremos pug como una view engine, y esto le dirá a Express que busque templeates in view subdirectory.

    {
        // View engine setup
    app.set("views", path.join(__dirname, "views"));
    app.set("view engine", "pug");

    }

    If you look in the views directory you will see the .pug files for the project's 
    default views. These include the view for the home page (index.pug) and base template (layout.pug) that we will need to replace with our own content.
        /express-locallibrary-tutorial  //the project root
        /views
        error.pug
        index.pug
        layout.pug

    ============ Template syntax

    https://pugjs.org/language/plain-text.html
    El ejemplo de archivo template de abajo muestra (show off) muchas de las características más útiles de Pug's.

    The first thing to notice is that the file maps the structure of a typical HTML file, with the first word in (almost)
    every line being an HTML element, and indentation being used to indicate nested elements. So for example, the body 
    element is inside an html element, and paragraph elements (p) are within the body element, etc. Non-nested elements
    (e.g. individual paragraphs) are on separate lines.
    {
        doctype html
    html(lang="en")
    head
        title= title
        script(type='text/javascript').
    body
        h1= title

        p This is a line with #[em some emphasis] and #[strong strong text] markup.
        p This line has un-escaped data: !{'<em> is emphasized</em>'} and escaped data: #{'<em> is not emphasized</em>'}.
        | This line follows on.
        p= 'Evaluated and <em>escaped expression</em>:' + title

        <!-- You can add HTML comments directly -->
        // You can add single line JavaScript comments and they are generated to HTML comments
        //- Introducing a single line JavaScript comment with "//-" ensures the comment isn't rendered to HTML

        p A line with a link
        a(href='/catalog/authors') Some link text
        |  and some extra text.

        #container.col
        if title
            p A variable named "title" exists.
        else
            p A variable named "title" does not exist.
        p.
            Pug is a terse and simple template language with a
            strong focus on performance and powerful features.

        h2 Generate a list

        ul
        each val in [1, 2, 3, 4, 5]
            li= val

    }

    Los elemntos atributos  (atributos a secas xdd) son definidos con parentessis después de sus elemento asociado. 
    Dentro de los paréntesis, los atributos se definen en listas separadas por comas o espacios en blanco de los 
    pares de nombres de atributos y valores de atributos, por ejemplo:
    {
        script(type='text/javascript'), link(rel='stylesheet', href='/stylesheets/style.css')
        meta(name='viewport' content='width=device-width initial-scale=1')
    }

    Si la etiqueta esta seguida por un signo de igual (=), el siguiente texto es tratado como una expresión html.
    {
        h1= title
        p= 'Evaluated and <em>escaped expression</em>:' + title

    }
    Si no tiene un signo de igual, este contenido es tratado como n texto explicativo. Dentro de este podes
    aplicar escaped y unescaped data usando #{} and !{} syntaxis respectivamente, como mostramos abajo.
    {
        p This is a line with #[em some emphasis] and #[strong strong text] markup.
        p This line has an un-escaped string: !{'<em> is emphasized</em>'}, an escaped string: #{'<em> is not emphasized</em>'}, and escaped variables: #{title}.
 
    }


    Nota: casi siempre querrá escapar de los datos de los usuarios (a través de la sintaxis #{}). Los datos en los 
    que se puede confiar (por ejemplo, recuentos de registros generados, etc.) se pueden mostrar sin escapar de 
    los valores.

    Tu también puedes usar ('|') para comenzar una linea indicando "texto plano". El texto plano es, cualquier
    coigo o texto que debería ir, sin procesar, directamtne a renderizarse como HTML. Estos son útiles en diferentes situaciones.
    {
        a(href='http://someurl/') Link text
        | Plain text

    }

    Pugs te permite realizar conficionales utilizando if, else, else if y unless, for ejemplo: 
    {
        if title
            p A variable named "title" exists
        else
            p A variable named "title" does not exist

    }

    Tambien puede hacer iteraciones utilizando each.in o while syntax.  In the code fragment below we've 
    looped through an array to display a list of variables (note the use of the 'li=' to evaluate the 
    "val" as a variable below. The value you iterate across can also be passed into the template as a 
    variable!

    {
        ul
            each val in [1, 2, 3, 4, 5]
        li= val

    }

    La syntaxis también soporta comentarios ( que seran renderizados en el output o no, como decis)
    creando bloques reusables de codigo, testamentos de cado y otras características. Para más inforamción,
    poder ir a https://pugjs.org/api/getting-started.html

    ==== Extending templates
    Al rededor del sitio, es usual que todas las paginas tgengan una estructura en común, incluyendo un standar de HTML 
    para el head, footer, navigaton,etc. 

    En lugar de (rahter than ) forzar a los desarrolladores a duplicar este "modelo" en cada página,
    pugs permite declarar una base de templeats y extenderlo, reemplazando sólo las partes
    que son diferentes para cada pagina específica.

    For ejemplo, la base del template layout.pug creada en el esqueleto del proyecto es como esta:
    {
        doctype html
        html
        head
            title= title
            link(rel='stylesheet', href='/stylesheets/style.css')
        body
            block content

    }
    La etiqueta block es usada para marcar secciones de contenido que tal vez reemplacemos en derivadas templeates(si 
    el blockno se redefine, se usa su implementación en la clase base)

    El default index.pug(creado en nuestro projecto) muestra como nosotros anulamos la base del template.
    La etiqueta extends tag identifica una base de template que utilizaremos, y luego usamos block section_name
    para inicar el nuevo contenido en la sección que será anulado.

    {
        extends layout

        block content
        h1= title
        p Welcome to #{title}

    }

    ================== LocalLibrary base template
    Ahora vamos a entender como se extienden las template sutilziando PUG, vamos a crear una base de    
    template para nuestro projecto. Este tendrá una sidebar con links de las paginas que vamos a crear a lo largo 
    del los articulos del tutuorial (ej desplegando y creando libros, generos, autores, etc) y el contenido main 
    sera invalidado en cada una de nuestras paginas inividuales.

    Abrimos views/layouts.pug y reemplazamos el contenido existente por el código de abajo: 
    {

        doctype html
        html(lang='en')
        head
            title= title
            meta(charset='utf-8')
            meta(name='viewport', content='width=device-width, initial-scale=1')
            link(rel="stylesheet", href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css", integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z", crossorigin="anonymous")
            script(src="https://code.jquery.com/jquery-3.5.1.slim.min.js", integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj", crossorigin="anonymous")
            script(src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js", integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV", crossorigin="anonymous")
            link(rel='stylesheet', href='/stylesheets/style.css')
        body
            div(class='container-fluid')
            div(class='row')
                div(class='col-sm-2')
                block sidebar
                    ul(class='sidebar-nav')
                    li
                        a(href='/catalog') Home
                    li
                        a(href='/catalog/books') All books
                    li
                        a(href='/catalog/authors') All authors
                    li
                        a(href='/catalog/genres') All genres
                    li
                        a(href='/catalog/bookinstances') All book-instances
                    li
                        hr
                    li
                        a(href='/catalog/author/create') Create new author
                    li
                        a(href='/catalog/genre/create') Create new genre
                    li
                        a(href='/catalog/book/create') Create new book
                    li
                        a(href='/catalog/bookinstance/create') Create new book instance (copy)

                div(class='col-sm-10')
                block content

    }

    La templeates usa (e inclute) JavaScript y CSS de bootstrap para mejorar ( impove ) la vista y 
    la presentación de la página html. Usando bootstrap o otro clent-side ( lado del cliente ) web framework
    es un camino rapido para crear una pagina atractiva que tiene una buena escala en diferentes navegadores,
    y tambien nos permite tratar con la presentacion de la pagina sin tener que entrar dentro
    de ningun detalle, nosotros sólo queremos centrarnos en el server-side (espacio del servidor) en este código

    La base de datos hace referencia a un esstilo css local que provee
    un poco de información adicional de css, este en public/stylesheets/style.css

    {
        .sidebar-nav {
        margin-top: 20px;
        padding: 0;
        list-style: none;
        }

    }

    Ahora tenemos una pagina con una sidebar. En la sig sección la usaremos para definir paginas individuales

    =================== Home Page
    The first page we'll create will be the website home page, which is accessible from either the site ('/') 
    or catalog (catalog/) root. This will display some static text describing the site, along with dynamically
     calculated "counts" of different record types in the database.

    We've already created a route for the home page. In order to complete the page we need to update our controller 
    function to fetch "counts" of records from the database, and create a view (template) that we can use to render the page.

    ===== Route
    Creamos nuestro index en tutoriales previos. Para recordar, todas las funciones de rutas estan definidas en routes/catalog

    {
        // GET catalog home page.
        router.get("/", book_controller.index); //This actually maps to /catalog/ because we import the route with a /catalog prefix

    }

    Donde el callback llama a la función (book_controller.index) el cual es definido en /controller/bookController.js
    {
        exports.index = (req, res, next) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };

    }
    En este controlador vamos a extender la infroacmión de nuestro modelo y la renderizaremos utilizando la view


    ==== Controller
    The index controller function needs to fetch information about how many Book, BookInstance, available BookInstance,
    Author, and Genre records we have in the database, render this data in a template to create an HTML page, 
    and then return it in an HTTP response.

    {
        Note: We use the countDocuments() method to get the number of instances of each model. This is called on a model,
        with an optional set of conditions to match against in the first argument, and a callback in the second argument 
        (as discussed in Using a Database (with Mongoose), and you can also return a Query and then execute it with a 
        callback later). The callback will be invoked when the database returns the count, with an error value as the
        first parameter (or null) and the count of documents as the second parameter (or null if there was an error) .

        {
            SomeModel.countDocuments({ a_model_field: "match_value" }, (err, count) => {
            // Do something if there is an err
            // Do something with the count if there was no error
            });

        }
    }
    
    Abrimos /controllers/bookController.js. Cerca del top de nuestro archivo exportamos la función index
    {
        const Book = require("../models/book");

        exports.index = (req, res, next) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };
    }

    y Ahora remplazamos todo el codigo de arriba con el siguiente fragmento. Lo primero es importart (require()) todos 
    los modelos. Los encesitamos porque vamos a usarlos para contar los documentos. También importanmos
    el modulo async (como discutimos previamente en Asynchronous flow control using async)

    {
        const Book = require("../models/book");
        const Author = require("../models/author");
        const Genre = require("../models/genre");
        const BookInstance = require("../models/bookinstance");

        const async = require("async");

        exports.index = (req, res) => {
        async.parallel(
            {
            book_count(callback) {
                Book.countDocuments({}, callback); // Pass an empty object as match condition to find all documents of this collection
            },
            book_instance_count(callback) {
                BookInstance.countDocuments({}, callback);
            },
            book_instance_available_count(callback) {
                BookInstance.countDocuments({ status: "Available" }, callback);
            },
            author_count(callback) {
                Author.countDocuments({}, callback);
            },
            genre_count(callback) {
                Genre.countDocuments({}, callback);
            },
            },
            (err, results) => {
            res.render("index", {
                title: "Local Library Home",
                error: err,
                data: results,
            });
            }
        );
        };

    }

    Al método async.parallel() se le pasa un objeto con funciones para obtener los recuentos de cada 
    uno de nuestros modelos. Todas estas funciones se inician al mismo tiempo. Cuando todos 
    han completado, se invoca la devolución de llamada final con los recuentos en el parámetro 
    de resultados (o un error).

    Si todo estrá bien, el callback del segundo parametro se ejecuta , especificando la vista llamada "Index"
    y un objeto que contiene la data que sera insertada dentro de este ( este incluyeu un objeto de resultado que
    contiene nuestras cuentas del modelo). La data es suministrada ( supplied ) como pares clave-valor, y puede ser
    accesible en nuestra templete utilizando las keys.

    Nota: La función de devolución de llamada de async.parallel() anterior es un poco inusual en 
    el sentido de que representamos la página haya o no un error (normalmente, puede usar una ruta
     de ejecución separada para manejar la visualización de errores). Tipo renderizas otra template
     para manejar estos errores.

    ===== View
    Abrimos /views/layouts/index.pug y reemplazamos el contenido con el texto de debajo
    {
        extends layout

        block content
        h1= title
        p Welcome to #[em LocalLibrary], a very basic Express website developed as a tutorial example on the Mozilla Developer Network.

        h1 Dynamic content

        if error
            p Error getting dynamic content.
        else
            p The library has the following record counts:

            ul
            li #[strong Books:] !{data.book_count} // esto podría ser un b, no necesitariamente strong, basicamente lo
            que hace #[es el evitar pasar de linea, es como una linea dentro de otra, ya que recordemos, cada etiqueta se usa en una linea]
            li #[strong Copies:] !{data.book_instance_count}
            li #[strong Copies available:] !{data.book_instance_available_count} // Y esto es para poner la data noma,tranqui
            li #[strong Authors:] !{data.author_count}
            li #[strong Genres:] !{data.genre_count}

    }

    La vista es sencilla (straightforward - derecha hacia adelante). Extenedemos la layout.pug, primordiando el block 
    llamado "content". The first h1 heading will be the escaped text for the title variable that was passed into 
    the render() function—note the use of the 'h1=' so that the following text is treated as a 
    JavaScript expression. We then include a paragraph introducing the LocalLibrary.

    Under the Dynamic content heading we check whether the error variable passed in from the render() 
    function has been defined. If so, we note the error. If not, we get and list the number of copies 
    of each model from the data variable

    Nota: No escapamos de los valores de conteo (es decir, usamos la sintaxis !{}) porque se calculan 
    los valores de conteo. Si la información fue proporcionada por los usuarios finales, escaparíamos 
    de la variable para mostrarla.


    ====================== Book list Page
    Ahora vamos a implementar nuestra llist page. Esta pagina necesita desplegar una lista de todos los libros en
    la base de datos al rededor de su author, con cada titulo siendo un hyperlink asociado a los book detail page.

    ==== Controller
    The book list controller function needs to get a list of all Book objects in the database, sort them, 
    and then pass these to the template for rendering.

    Open /controllers/bookController.js. Find the exported book_list() controller method and replace it 
    with the following code.

    {
        // Display list of all Books.
        exports.book_list = function (req, res, next) {
        Book.find({}, "title author")
            .sort({ title: 1 })
            .populate("author")
            .exec(function (err, list_books) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("book_list", { title: "Book List", book_list: list_books });
            });
        };

    }

    El metodo utilizando en este modelo find() function devuelve todos los Book object, seleccionando 
    para devolver sólo title and author ya que nosotros no necesitamos otros archivos (it will also return the
    _id and virtual fiels) y entonces ordena (sorts) los resultados con el titulo alfabeticamente usando el metodo sort().
    Aqui nosotros llamamdo populated() en Libro, especialmente en el apartado de author - este reemplazará lo almacenado en
    author id con todos los detalles del author.

    sobre el existo, el callback pasará a una peticion para renderizar book_list.pug template, pasando el titulo
    y la lista de libros (lista de libros con autores) como variables

    === VIEW 
    Por lo que viendo lo de antes, creamos views/book_list.pug y copiamos el texto de debajo

    {
        extends layout

        block content
        h1= title

        ul
            each book in book_list
            li
                a(href=book.url) #{book.title}
                |  (#{book.author.name})

            else
            li There are no books.

    }

    The view extends the layout.pug base template and overrides the block named 'content'. 
    It displays the title we passed in from the controller (via the render() method) and iterates 
    through the book_list variable using the each-in-else syntax. A list item is created for each 
    book displaying the book title as a link to the book's detail page followed by the author name. 
    If there are no books in the book_list then the else clause is executed, and displays the text 
    'There are no books'.

    {
        Note: We use book.url to provide the link to the detail record for each book (we've implemented 
        this route, but not the page yet). This is a virtual property of the Book model which uses 
        the model instance's _id field to produce a unique URL path.
    }

    Of interest here is that each book is defined as two lines, using 
    the pipe for the second line. This approach is needed because if the 
    author name were on the previous line then it would be part of the hyperlink.

    ========== Bookinstance list page
    Ahora vamos a implementar nuestra list de todas las copias de los libros (bookinstance) en la libreria. Esta pagina
    necesita incluir el titulo del libro, asociado a cada BookInstance ( linkeando esto a su pagina de detalles) a lo
    largo con otra información en bookinstance model, incluyendo status, imprintm y la id unica de cada copia. 
    The unique id text deberia estar asociadao con la BookInstance detail page.

    === Controller
    The bookInstance list controller funcion necesito obtener una lsita de todas las book instances, populando
    la información asociada al libro, y esta pasa una lista a la tempalte para renderizarlo.

    Abrimos /controllers/bookinstanceController.js. Y rellenamos la exportación bookinstance_list() controlador metodo y 
    reemplazamos esto con el siguiente código: 

    {
        // Display list of all BookInstances.
        exports.bookinstance_list = function (req, res, next) {
        BookInstance.find()
            .populate("book")
            .exec(function (err, list_bookinstances) {
            if (err) {
                return next(err);
            }
            // Successful, so render
            res.render("bookinstance_list", {
                title: "Book Instance List",
                bookinstance_list: list_bookinstances,
            });
            });
        };

    }
    El metodo usa find() function para retornar todas las bookInstances. luego conecta en cadena una 
    llamada a populate() con el campo de libro; esto reemplazará la identificación del libro almacenada 
    para cada BookInstance con un documento de libro completo.

    On success, the callback passed to the query renders the bookinstance_list(.pug) 
    template, passing the title and bookinstance_list as variables.

    ==== VIEW 
    Creamos /Views/bookinstance_list.pug y copiamos el texto de abajo
    {
        extends layout

        block content
        h1= title

        ul
            each val in bookinstance_list
            li
                a(href=val.url) #{val.book.title} : #{val.imprint} -
                if val.status=='Available'
                span.text-success #{val.status}
                else if val.status=='Maintenance'
                span.text-danger #{val.status}
                else
                span.text-warning #{val.status}
                if val.status!='Available'
                span  (Due: #{val.due_back} )

            else
            li There are no book copies in this library.

    }

    Esta vista es casi lo mismo que las otras. Esta se extiende del layout, teemplazando content block, 
    despliega un titulo pasado por el controlador, e itera a travez de todas las copias de los libros 
    en bookInstance_list. Para cada copia el despliega su status (con color ) y si el libro no esta
    disponible, este returna el dato, de cuando volverá. Una nueva característica es introducida- podemosusar una 
    identación con un punto ( . ) luego de la etiqueta para asignar una clase. Entonces span.text-success puede ser
    compilado com <span class="text-success">, este también podría ser escrico como span(class="text-succes")


    ========= DATE FORMATTTING USING LUXON
    El renderizado po defecto de los dates de las bookinsntaces es muy feo: 
    " (Due: Sat Dec 31 2022 15:17:05 GMT-0300 (hora estándar de Argentina) )". 
    En esta sección vamos a ver como puedes actualizar bookinstance list page de la sección previa
    para preentar due_Date field en un formato más amigable: Dec 31th, 2022.

    Para accercarse ( approach ) usaremos para crear una propiedad virtual en nuestro modelo de bookinstance, que nos
    devolverá la fecha formateada :D . Haremos que el formato actual cambie usando luxon, una poderosa, moderna 
    y amigable libreria para pasar, validar manipular, formatear y localizar datos.

    Nota: es posible usar luxon para formatear las string directamente en nuestras templates de pug, o 
    podemos formatear las string de varioas otras formas. Utilizando una propiedad virtual, nos permite
    obtener esa data formateada de exactamente la misma forma en la que obtenemos due_date actualmente.

    Note: este tutorial previamente usó moment library para formatear la libreria. Nos mudamos a luxon porque
    moment se ha declarado "legado" (legacy). Luxon es uno de los moment project0s main recommendations para
    una nueva libreria alternativa.

    ==== Install Luxon
    Ponemos el siguiente comando en la terminar del proyecto:
    npm install luxon

    ==== Creamos una propiedad virtual
    1. abrimos ./models/bookinstance.js
    2. en la parte de arriba de la pagina, importamos luxon.

        const { dateTime } = require("luxon");

    Añadimos la propiedad virtual de due_back_formated justo después de la propiedad URL
    {
        BookInstanceSchema.virtual("due_back_formatted").get(function () {
        return DateTime.fromJSDate(this.due_back).toLocaleString(DateTime.DATE_MED);
        });

    }

    Note: Luxon puede importar string de varios formatos y exportar ambos predefinidos y free.form formats.
    En este caso nosotros usamos formJSDate() para importar un dato string de js Y toLocalSstring() para
    lanzar el dato en date_med formato en ingles. Oct 6th,2022. Para más información acerca de los formates y
    los datos de string, mirar la documentación de string en: https://github.com/moment/luxon/blob/master/docs/formatting.md#formatting

    == Update the view
    Abrimos /view/bookinstance_list.pug y reemplazamos due_back por due_back_formatted 
    {
        if val.status != 'Available'
        //span  (Due: #{val.due_back} )
        span  (Due: #{val.due_back_formatted} )

    }

    ======================== Author list page and Genre list page Challenge
    The author list page needs to displaya a list of all authors in the database, witheach author
    name linked to its associated author detail page. The date of birth and date of death should be listed
    after the name on the same line.

    === Controller
    The author list controller function needs to get a list of all Author instances, 
    and then pass these to the template for rendering.

    Open /controllers/authorController.js. Find the exported author_list() controller
    method near the top of the file and replace it with the following code.

    {
            // Display list of all Authors.
        exports.author_list = function (req, res, next) {
        Author.find()
            .sort([["family_name", "ascending"]])
            .exec(function (err, list_authors) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("author_list", {
                title: "Author List",
                author_list: list_authors,
            });
            });
        };

    }

    The method uses the model's find(), sort() and exec() functions to return all 
    Author objects sorted by family_name in alphabetic order. The callback passed
    to the exec() method is called with any errors (or null) as the first parameter,
    or a list of all authors on success. If there is an error it calls the next middleware 
    function with the error value, and if not it renders the author_list(.pug) template, 
    passing the page title and the list of authors (author_list).


    ==== VIEW
    Creamos /views/author_list.pug y ponemos el conteido de debajo 
    {
        extends layout

        block content
        h1= title

        ul
            each author in author_list
            li
                a(href=author.url) #{author.name}
                |  (#{author.date_of_birth} - #{author.date_of_death})

            else
                li There are no authors.



    }

    ========== Genre list page --- challenge!
    En esta seccion tu deberas implementar tu propia genre list page. La pagina deberia desplegar una lista
    de todos los generos de la base de datos, con cada genero linkeado a su associated details page. 

    Para esto tenemos que modificar el genre_controller, el export.genre_list con el sig codigo: 
    {
        // Display list of all Genre.
        exports.genre_list = function (req, res, next) {
        Genre.find()
            .sort([["name", "ascending"]]) 
            .exec(function (err, list_genre) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("genre_list", {
                title: "Genre List",
                genre_list: list_genre,
            });
        });
        };

    }

    Este es practicamente lo mismo que hicimos con author
    Luego creamos la view genre_list.pug y ponemos lo siguiente: 
    {
        extends layout

        block content
        h1= title

        ul
            each genre in genre_list
            li
                a(href=genre.url) #{genre.name}

            else
            li There are no genres.  
    }


    ================== Genre Detail Page
    El genere detail pagina necesita la información en particual de cada instancia de genero, usando el
    _id generado automáticamente. la pagina debería mostrar una lista de generos y una lista de todos los
    libros con el género de la pag

    ==== Controller
    abrimos /Controllers/genreController.js e importamos async y el modulo book en el top del archivo
    {
        const Book = require("../models/book");
        const async = require("async");

    }

    Rellenamos la exportación genre_details() controller method y ponemos el siguiente condigo 

    {
        // Display detail page for a specific Genre.
        exports.genre_detail = (req, res, next) => {
        async.parallel(
            {
            genre(callback) {
                Genre.findById(req.params.id).exec(callback);
            },

            genre_books(callback) {
                Book.find({ genre: req.params.id }).exec(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            if (results.genre == null) {
                // No results.
                const err = new Error("Genre not found");
                err.status = 404;
                return next(err);
            }
            // Successful, so render
            res.render("genre_detail", {
                title: "Genre Detail",
                genre: results.genre,
                genre_books: results.genre_books,
            });
            }
        );
        };

    }

    El metodo usado es async.parallel() para peticiones de genero name y es asociado con libros en paralelo, con el
    callback renderizando la pagina cuando (if) ambas request son completadas.

    El ID de la request registro es codigicadod de el final de la UTL y extraida automáticamente de la definicion
    de ruta (genre/:id). La id es accesible dentro del controllador utilizando req.params.id. Esto es
    usado con genre.findById() para obtener el genero en cuestion. Esto también es usado para obtener el objeto Book
    el cual tiene un genero ID en su campo de genero: Book.find({'genre': req.params.id})


    Note: si el genero no existe en la base de datos ( p.e si está elimindo) este finById() retornará exito pero no 
    resultados. En este caso, nosotros podemos desplegar un "not found" page, para crear un objeto de error y pasar 
    al siguiente middleware function en la cadena.
    {
        if (results.genre == null) {
        // No results.
        const err = new Error("Genre not found");
        err.status = 404;
        return next(err);
        }

    }
    El mensaje  será propagado a trabez de nuestro codigo manejador de errores ( este fue generado cuando nosotros
    generamos el esqueleto de la app - para más información mira: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction#handling_errors)

    Para renderizar la vista genre_details y que este pase variables para el titulo, genero y la lista de libros de
    este genero (genre_books)

    === VIEW
    Creamos genre_details.pug en views y ponemos el siguiente código:
    {
        extends layout

        block content

        h1 Genre: #{genre.name}

        div(style='margin-left:20px;margin-top:20px')

            h4 Books

            dl
            each book in genre_books
                dt
                a(href=book.url) #{book.title}
                dd #{book.summary}

            else
                p This genre has no books

    }
    Esta vista es muy similar a todas las otras templates. La principal diferencia es que esta no usa un titulo 
    pasado en el primer encabedazo ( pero esta si es usado en la subyacente layout.pug template para asignar
    el titulo de la página)


    Aquí hay un error que podrías obtener similar a este: 
        Cast to ObjectId failed for value " 59347139895ea23f9430ecbb" at path "_id" for model "Genre"
    Este es un error de mongoose vineindo de req.params.id. Para resolver este problema, primero necesitasmandar un require
    de mongoose en genreController.js page like this 
    
    const mongoose = require("mongoose");

    en el ejemplo utilizamos mongoose.Types.ObjectId() para convertir el id del type para poder ser usado, por ejemplo:

    {
    exports.genre_detail = (req, res, next) => {
    const id = mongoose.Types.ObjectId(req.params.id);
    // …
    };

    }

    ================= Book Detail page
    La pagina de detalles de libros necesita desplegar información para un libro especifico (odentificado usando
    su campo _id generado automáticamente), a lo largo con inforamción acerca de cada copia asociada 
    en la libreria ( bookInsntace ). Donde sea, desplegaremos el author, genre y bookInstance, estos deberían ser
    asociados con un link a su respectiva página.


    ===== Controller
    Abrimos /controllers/bookController.js. Rellenamos la exporación book_detail() controller method y reemplazamos 
    con el código de abajo: 
    {
                    // Display detail page for a specific book.
            exports.book_detail = (req, res, next) => {
            async.parallel(
                {
                book(callback) {
                    Book.findById(req.params.id)
                    .populate("author")
                    .populate("genre")
                    .exec(callback);
                },
                book_instance(callback) {
                    BookInstance.find({ book: req.params.id }).exec(callback);
                },
                },
                (err, results) => {
                if (err) {
                    return next(err);
                }
                if (results.book == null) {
                    // No results.
                    const err = new Error("Book not found");
                    err.status = 404;
                    return next(err);
                }
                // Successful, so render.
                res.render("book_detail", {
                    title: results.book.title,
                    book: results.book,
                    book_instances: results.book_instance,
                });
                }
            );
            };

    }
    Note: No neceistamos requerir async en y BookInstance en este paso, porque ya fue importado cuando creamos 
    el home page controller, el index.

    El methodo usado async.parallel() para encontrar Book y sus copias asociadas (bookInstances) en paralelo. 
    El acercamiento es exactamente el mismo como describimos para el Genre detail page. Desde la clave "title"
    la cual es usada para dar el nombre de la webpage (la cual definimos en el layout), esta vez estamos pasando
    results.book.title mientras renderizamos la webpage.

    === VIEW 
    Creamos una /view/book_detail.pug y ponemos el texto de abajo
    {
        extends layout

        block content
        h1 Title: #{book.title}

        p #[strong Author:]
            a(href=book.author.url) #{book.author.name}
        p #[strong Summary:] #{book.summary}
        p #[strong ISBN:] #{book.isbn}
        p #[strong Genre:]
            each val, index in book.genre // Recordemos que el campo de genero dentro del modelo de los libros, es un array con objetos genre adentro

            a(href=val.url) #{val.name}
            if index < book.genre.length - 1
                |,

        div(style='margin-left:20px;margin-top:20px')
            h4 Copies

            each val in book_instances
            hr
            if val.status=='Available'
                p.text-success #{val.status}
            else if val.status=='Maintenance'
                p.text-danger #{val.status}
            else
                p.text-warning #{val.status}
            p #[strong Imprint:] #{val.imprint}
            if val.status!='Available'
                p #[strong Due back:] #{val.due_back}
            p #[strong Id:]
                a(href=val.url) #{val._id}

            else
            p There are no copies of this book in the library.

    }
    La lista de generos asociada con el libro es implementada en la templette como vemos abajo.
    Esta añade una , después de cada genero asociado menos por el último.
    {
          p #[strong Genre:]
        each val, index in book.genre
        a(href=val.url) #{val.name}
        if index < book.genre.length - 1
            |,

    }

    ================ Author detail page
    El author detail pags necesita la información acerca de cada Author especificado, identificandolo
    utilizando su campo _id, a lo largo con una lista de todos los objetos Book asociado con el author

    ==== Controller 
    Abrimos /controllers/authorController.js
    Añadimos las siguientes lineas en la parte de arriba del archivo e importamos async y el modulo Book (estos
    son necesarios para nuestro author detail page)
    {
        const async = require("async";
        const Book = require("../models/book");
    }
    Luego rellenamos la exportación de author_details con el siguiente código:
    {
        // Display detail page for a specific Author.
        exports.author_detail = (req, res, next) => {
        async.parallel(
            {
            author(callback) {
                Author.findById(req.params.id).exec(callback);
            },
            authors_books(callback) {
                Book.find({ author: req.params.id }, "title summary").exec(callback);
            },
            },
            (err, results) => {
            if (err) {
                // Error in API usage.
                return next(err);
            }
            if (results.author == null) {
                // No results.
                const err = new Error("Author not found");
                err.status = 404;
                return next(err);
            }
            // Successful, so render.
            res.render("author_detail", {
                title: "Author Detail",
                author: results.author,
                author_books: results.authors_books,
            });
            }
        );
        };

    }

    El metodo usado es async.oarakkek() para pedir el Author y a su libro asociado en paralelo. con 
    el ballbback de renderizan la pagina si ambas peticiones son completadas correctamente. El acercamiento
    es exactamente el mismo para describir el genre detail page de antes.

    === VIEW
    Creamos / view/ author_detail.pug y copaimos el siguiente texto

    ============ BookInstance detail page
    The BookInstance detail page needs to display the information for each BookInstance, identified using its
    (automatically generated) _id field value. This will include the Book name (as a link to the Book detail page) 
    along with other information in the record.

    === Controller 
    Abrimos controllers/bookInsntaceController.js y dentro de bookinstance_Detail controller ponemos lo siguiente.
    {
        // Display detail page for a specific BookInstance.
        exports.bookinstance_detail = (req, res, next) => {
        BookInstance.findById(req.params.id)
            .populate("book")
            .exec((err, bookinstance) => {
            if (err) {
                return next(err);
            }
            if (bookinstance == null) {
                // No results.
                const err = new Error("Book copy not found");
                err.status = 404;
                return next(err);
            }
            // Successful, so render.
            res.render("bookinstance_detail", {
                title: `Copy: ${bookinstance.book.title}`,
                bookinstance,
            });
            });
        };

    }

    El metodo llama a BookInstance.findById() con la id especifica del book instance extraido de la utl, y accede
    via una peticion del controllador con el parametro id del req params. Y este llama a populated para acceder
    a los libros asociadoos

    === VIEW
    views/bookinstance_detail.pug
    {

    }


    ====== Challenge
    Tenes que agregar una propiedad virtual a todos los Date de los modelos utilizando luxon.
    Currently most dates displayed on the site use the default JavaScript format (e.g. Tue Oct 06 2020 15:49:58 GMT+1100 
    (AUS Eastern Daylight Time)). The challenge for this article is to improve the appearance of the date display 
    for Author lifespan information (date of death/birth) and for BookInstance detail pages to use the format: Oct 
    6th, 2016.

    // Parece que ese formato choto lo pasa siempre sin importar cómo lo hayas hecho, porque en el ejemplo, en 
    populated lo hicieron como: 1920-01-02

    Note: You can use the same approach as we used for the Book Instance List (adding the virtual property 
    for the lifespan to the Author model and use luxon to format the date strings).

    To complete this challenge, you must:

    Replace the variable due_back with due_back_formatted in the BookInstance detail page.
    Update the Author model to add a lifespan virtual property. The lifespan should look like: date_of_birth 
    - date_of_death, where both values have the same date format as BookInstance.due_back_formatted.
    Use Author.lifespan in all views where you currently explicitly use date_of_birth and date_of_death.


    ------------------- SUMMARY RESUMEN
    Ya hemos creado todo lo "sólo lectura" de nuestra site: a home page that displays counts of instances 
    of each of our models, and list and detail pages for our books, book instances, authors, and genres. 
    Along the way, we've gained a lot of fundamental knowledge about controllers, managing flow control
    when using asynchronous operations, creating views using Pug, querying the site's database using models, 
    passing information to a view, and creating and extending templates. The challenges will also have taught 
    readers a little about date handling using Luxon.

    En nuestro proximo articulo, construiremos nuestro conocimiento (knowledge), creando formularios HTML 
    y código de manejo de formularios para comenzar a modificar los datos almacenados por el sitio.   
]

    ==== D E S A R R O L L O  6 - Working with forms ==== Creación del CRUD
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/forms
[
    In this tutorial we'll show you how to work with HTML Forms in Express using Pug. In particular, we'll
    discuss how to write forms to create, update, and delete documents from the site's database.

    Objetivo: to understand how to write forms to get data form users, and update the
    database with this data

    ================ Overview
    Un formulario son algunos digets ocampos de la web que son usados para recolectar información 
    de los usuarios y enviarlos al servidor. Forms are a flexible mechanism for collecting user 
    input because there are suitable form inputs available for entering many different types of
    data—text boxes, checkboxes, radio buttons, date pickers, etc. Forms are also a relatively 
    secure way of sharing data with the server, as they allow us to send data in POST requests 
    with cross-site request forgery protection.

    Working with forms can be complicated! Developers need to write HTML for the form, validate 
    and properly sanitize entered data on the server (and possibly also in the browser), repost 
    the form with error messages to inform users of any invalid fields, handle the data when it 
    has successfully been submitted, and finally respond to the user in some way to indicate success.

    In this tutorial, we're going to show you how the above operations may be performed in Express. 
    Along the way, we'll extend the LocalLibrary website to allow users to create, edit and delete 
    items from the library

    Note: We haven't looked at how to restrict particular routes to authenticated or authorized
    users, so at this point, any user will be able to make changes to the database.

    ========= HTML Forms
    First a brief overview of HTML Forms. Consider a simple HTML form, with a 
    single text field for entering the name of some "team".

    The form is defined in HTML as a collection of elements inside <form>…</form> tags, 
    containing at least one input element of type="submit".
    {
        <form action="/team_name_url/" method="post">
        <label for="team_name">Enter name: </label>
        <input
            id="team_name"
            type="text"
            name="name_field"
            value="Default name for team." />
        <input type="submit" value="OK" />
        </form>

    }
    While here we have included just one (text) field for entering the team name, a 
    form may contain any number of other input elements and their associated labels. 
    The field's type attribute defines what sort of widget will be displayed. The name 
    and id of the field are used to identify the field in JavaScript/CSS/HTML, while 
    value defines the initial value for the field when it is first displayed. The matching 
    team label is specified using the label tag (see "Enter name" above), with a 
    for field containing the id value of the associated input.

    The submit input will be displayed as a button (by default)—this can be 
    pressed by the user to upload the data contained by the other input 
    elements to the server (in this case, just the team_name). The form attributes
    define the HTTP method used to send the data and the destination of 
    the data on the server (action):

    action: The resource/URL where data is to be sent for processing when the form 
    is submitted. If this is not set (or set to an empty string), then the form will 
    be submitted back to the current page URL.
    method: The HTTP method used to send the data: POST or GET.
    The POST method should always be used if the data is going to result in a change 
    to the server's database, because this can be made more resistant to cross-site 
    forgery request attacks.
    The GET method should only be used for forms that don't change user data (e.g. 
    a search form). It is recommended for when you want to be able to bookmark or share the URL.

    ========== Form handling Process - Manejo de procesos del formulario
    https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/forms
    Form handling uses all of the same techniques that we learned for displaying information about 
    our models: the route sends our request to a controller function which performs any database 
    actions required, including reading data from the models, then generates and returns an HTML page. 
    What makes things more complicated is that the server also needs to be able to process the data 
    provided by the user, and redisplay the form with error information if there are any problems.

    A process flowchart for processing form requests is shown below, starting with a request for a page 
    containing a form (shown in green):
    {
        navegador --> pide por medio de HTTP get que le genere un --> default form --
                                                                                    |
        el usuario rellena este formulario <------------------------------------------
        | ----------> pide por emdio de HTTP POST enviar la data ---> se valida la data -- si es valido v, si no lo es A
                                                                                        |
        redireccióna al navegador con "succes" url <-----------------------------------crea acciones con la data
    }

    As shown in the diagram above, the main things that form handling code needs to do are:

    Display the default form the first time it is requested by the user.
    The form may contain blank fields (e.g. if you're creating a new record), or it may be pre-populated 
    with initial values (e.g. if you are changing a record, or have useful default initial values).
    Receive data submitted by the user, usually in an HTTP POST request.
    Validate and sanitize the data.
    If any data is invalid, re-display the form—this time with any user populated values and error messages 
    for the problem fields.
    If all data is valid, perform required actions (e.g. save the data in the database, send a notification 
    email, return the result of a search, upload a file, etc.)
    Once all actions are complete, redirect the user to another page.

    ============== Validación y desifección
    Before the data from a form is stored it must be validated and sanitized:

    Validation checks that entered values are appropriate for each field (are in the right range, format, etc.) 
    and that values have been supplied for all required fields.
    Sanitization removes/replaces characters in the data that might potentially be used to send malicious 
    content to the server.
    For this tutorial, we'll be using the popular express-validator ( https://www.npmjs.com/package/express-validator )module to perform both validation and 
    sanitization of our form data.

    Para instalarlo, solamente tenemos que correr en nuestra terminal:

    npm install express-validator

    ==============  Usando express-validator VALIDACION depuracion
    documentación: https://express-validator.github.io/docs/#basic-guide

    Note: The express-validator guide on GitHub provides a good overview of the API. 
    We recommend you read that to get an idea of all its capabilities (including using 
    schema validation and creating custom validators). Below we cover just a subset that 
    is useful for the LocalLibrary.

    To use the validator in our controllers, we specify the particular 
    functions we want to import from the express-validator module, as shown below:

    {
        const { body, validationResult } = require("express-validator"); // Esto quiere decir que sólo vamos a sacar 
        // de express validator, la función de body y validationResult
    }

    There are many functions available, allowing you to check and sanitize data from request parameters, 
    body, headers, cookies, etc., or all of them at once. For this tutorial, we'll primarily be using 
    body and validationResult (as "required" above).

    The functions are defined as below: Esta es la función de body:

    ==== express-validator BODY
    body([fields, message]): Specifies a set of fields in the request body (a POST parameter) 
    to validate and/or sanitize along with an optional error message that can be displayed if 
    it fails the tests. The validation and sanitize criteria are daisy-chained to the body() 
    method. For example, the line below first defines that we're checking the "name" field 
    and that a validation error will set an error message "Empty name". We then call the 
    sanitization method trim() to remove whitespace from the start and end of the string, 
    and then isLength() to check the resulting string isn't empty. Finally, we call escape() 
    to remove HTML characters from the variable that might be used in JavaScript cross-site scripting attacks.

    {
        [
    // …
    body("name", "Empty name").trim().isLength({ min: 1 }).escape(), //Empty name es el mensaje de error actual
                                                                    // pero el mensaje por defecto es "invalid value"
    // …
        ];
    }

    This test checks that the age field is a valid date and uses optional() 
    to specify that null and empty strings will not fail validation.

    {
            [
        // …
        body("age", "Invalid age")
            .optional({ checkFalsy: true })
            .isISO8601()
            .toDate(),
        // …
        ];

    }

    You can also daisy chain different validator, and add messages that are displayed if the
    preceding validators are true

    {   
        [
        // …
        body("name")
            .trim()
            .isLength({ min: 1 })
            .withMessage("Name empty.")
            .isAlpha()
            .withMessage("Name must be alphabet letters."),
        // …
        ];
    }

    ==== express-validator VALIDATIONRESULT(REQ)
    validationResult(req): Runs the validation, making errors available in the form of a 
    validation result object. This is invoked in a separate callback, as shown below:

    {
        (req, res, next) => {
        // Extract the validation errors from a request.
        const errors = validationResult(req);

        if (!errors.isEmpty()) {
            // There are errors. Render form again with sanitized values/errors messages.
            // Error messages can be returned in an array using `errors.array()`.
        } else {
            // Data from form is valid.
        }
        };
    }
    We use the validation result's isEmpty() method to check if there were errors, and its array()
    method to get the set of error messages. See the Validation Result API for more information

    The validation and sanitization chains are middleware that should be passed to the Express route handler 
    (we do this indirectly, via the controller). When the middleware runs, each validator/sanitizer is run 
    in the order specified.

    We'll cover some real examples when we implement the LocalLibrary forms below.

    ===================== FORM DESIGN Diseño del formulario
    Many of the models in the library are related/dependent—for example, a Book requires an Author, 
    and may also have one or more Genres. This raises the question of how we should handle the case 
    where a user wishes to:

        - Create an object when its related objects do not yet exist (for example, a book where the author object hasn't been defined).
        - Delete an object that is still being used by another object (so for example, deleting a Genre that is still being used by a Book).

    For this project we will simplify the implementation by stating that a form can only:
        - Create an object using objects that already exist (so users will have to create any required Author 
        and Genre instances before attempting to create any Book objects).
        - Delete an object if it is not referenced by other objects (so for example, you won't be able to 
        delete a Book until all associated BookInstance objects have been deleted).

    Note: A more "robust" implementation might allow you to create the dependent objects when 
    creating a new object, and delete any object at any time (for example, by deleting 
    dependent objects, or by removing references to the deleted object from the database)


    ================ Routes
    Para implementar nuestro codigo de manejo de formularios, we will need two routes that have the
    same URL pattern. The first (GET) route is used to display a new empty form for creating the object.
    The second route (POST) is used for validating data entered by the user, and then saving 
    the information and redirecting to the detail page (if the data is valid) or redisplaying the 
    form with errors (if the data is invalid).

    We have already created the routes for all our model's create pages in /routes/catalog.js 
    (in a previous tutorial). For example, the genre routes are shown below:
    {
        // GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).
        router.get("/genre/create", genre_controller.genre_create_get);

        // POST request for creating Genre.
        router.post("/genre/create", genre_controller.genre_create_post);

    }

    =================== PRACTICA =========================
    ============= Create genre form
    This sub article shows how we define our page to create Genre 
    objects (this is a good place to start because the Genre has only one 
    field, its name, and no dependencies). Like any other pages, we need
    to set up routes, controllers, and views.

    ===== Importamos los metodos de sanitzacion y calidacion

    To use the express-validator in our controllers we have to require 
    the functions we want to use from the 'express-validator' module.

    Open /controllers/genreController.js, and add the following line at the top of the file:

    {
        const { body, validationResult } = require("express-validator");

    }

    Note: this syntax allow us to use body and validationResult como unos middleware asociados a la función,
    como puedes ver en la sección de abajo. Esto es equivalente a:
    {
        const validator = require("express-validator");
        const body = validator.body;
        const validationResult = validator.validationResult;

    } 

    ====== Controller - get route GENRE
    Find the exported genre_create_get() controller method and replace it with the following code. 
    This renders the genre_form.pug view, passing a title variable.
    {
        // Display Genre create form on GET.
        exports.genre_create_get = (req, res, next) => {
        res.render("genre_form", { title: "Create Genre" });
        };

    }
    Sólo renderizamos una view, pasando simplemente un titulo.

    ===== Controller = POST route GENRE
    Find the exported genre_create_post() controller method and replace it with the following code.
    {
        // Handle Genre create on POST.
        exports.genre_create_post = [
        // Validate and sanitize the name field.
        body("name", "Genre name required").trim().isLength({ min: 1 }).escape(),

        // Process request after validation and sanitization.
        (req, res, next) => {
            // Extract the validation errors from a request.
            const errors = validationResult(req);

            // Create a genre object with escaped and trimmed data.
            const genre = new Genre({ name: req.body.name });

            if (!errors.isEmpty()) {
            // There are errors. Render the form again with sanitized values/error messages.
            res.render("genre_form", {
                title: "Create Genre",
                genre,
                errors: errors.array(),
            });
            return;
            } else {
            // Data from form is valid.
            // Check if Genre with same name already exists.
            Genre.findOne({ name: req.body.name }).exec((err, found_genre) => {
                if (err) {
                return next(err);
                }

                if (found_genre) {
                // Genre exists, redirect to its detail page.
                res.redirect(found_genre.url);
                } else {
                genre.save((err) => {
                    if (err) {
                    return next(err);
                    }
                    // Genre saved. Redirect to genre detail page.
                    res.redirect(genre.url);
                });
                }
            });
            }
        },
        ];

    }

    The first thing to note is that instead of being a single middleware function (with arguments 
    (req, res, next)) the controller specifies an array of middleware functions. The array is passed 
    to the router function and each method is called in order.

    Note: This approach is needed, because the validators are middleware functions.

    The first method in the array defines a body validator (body()) that validates and sanitizes 
    the field. This uses trim() to remove any trailing/leading whitespace, checks that the name 
    field is not empty, and then uses escape() to remove any dangerous HTML characters).
    {
        [
        // Validate that the name field is not empty.
        body("name", "Genre name required").trim().isLength({ min: 1 }).escape(),
        // …
        ];

    }

    After specifying the validators we create a middleware function to extract 
    any validation errors. We use isEmpty() to check whether there are any errors 
    in the validation result. If there are then we render the form again, passing 
    in our sanitized genre object and the array of error messages (errors.array()).

    {
        // Process request after validation and sanitization.
        (req, res, next) => {
        // Extract the validation errors from a request.
        const errors = validationResult(req);

        // Create a genre object with escaped and trimmed data.
        const genre = new Genre({ name: req.body.name });

        if (!errors.isEmpty()) {
            // There are errors. Render the form again with sanitized values/error messages.
            res.render("genre_form", {
            title: "Create Genre",
            genre,
            errors: errors.array(),
            });
            return;
        } else {
            // Form data is valid.
            // Save the result.
            // …
        }
        };

    }

    If the genre name data is valid then we check if a Genre with the same name already 
    exists (as we don't want to create duplicates). If it does, we redirect to the existing 
    genre's detail page. If not, we save the new Genre and redirect to its detail page.

    {
        // Check if Genre with same name already exists.
        Genre.findOne({ name: req.body.name }).exec((err, found_genre) => {
        if (err) {
            return next(err);
        }
        if (found_genre) {
            // Genre exists, redirect to its detail page.
            res.redirect(found_genre.url);
        } else {
            genre.save((err) => {
            if (err) {
                return next(err);
            }
            // Genre saved. Redirect to genre detail page.
            res.redirect(genre.url);
            });
        }
        });
    }

    This same pattern is used in all our post controllers: we run validators (with sanitizers), 
    then check for errors and either re-render the form with error information or save the data.

    ========== VIEW
    The same view is rendered in both the GET and POST controllers/routes when we create a new
    Genre (and later on it is also used when we update a Genre). In the GET case the
    form is empty, and we just pass a title variable. In the POST case the user has
    previously entered invalid data—in the genre variable we pass back a sanitized
    version of the entered data and in the errors variable we pass back an array
    of error messages.

    {
        res.render("genre_form", { title: "Create Genre" });
        res.render("genre_form", {
        title: "Create Genre",
        genre,
        errors: errors.array(),
        });

    }

    Create /views/genre_form.pug and copy in the text below.

    {
        extends layout

        block content
        h1 #{title}

        form(method='POST' action='')
            div.form-group
            label(for='name') Genre:
            input#name.form-control(type='text', placeholder='Fantasy, Poetry etc.' name='name' value=(undefined===genre ? '' : genre.name))
            button.btn.btn-primary(type='submit') Submit

        if errors
        ul
            for error in errors
            li!= error.msg

    }

    In this article
    Import validation and sanitization methods
    Controller—get route
    Controller—post route
    View
    What does it look like?
    Next steps
    Create genre form
    This sub article shows how we define our page to create Genre objects (this is a good place to start because the Genre has only one field, its name, and no dependencies). Like any other pages, we need to set up routes, controllers, and views.

    Import validation and sanitization methods
    To use the express-validator in our controllers we have to require the functions we want to use from the 'express-validator' module.

    Open /controllers/genreController.js, and add the following line at the top of the file:

    const { body, validationResult } = require("express-validator");
    Copy to Clipboard
    Note: This syntax allows us to use body and validationResult as the associated middleware functions, as you will see in the post route section below. It is equivalent to:

    const validator = require("express-validator");
    const body = validator.body;
    const validationResult = validator.validationResult;
    Copy to Clipboard
    Controller—get route
    Find the exported genre_create_get() controller method and replace it with the following code. This renders the genre_form.pug view, passing a title variable.

    // Display Genre create form on GET.
    exports.genre_create_get = (req, res, next) => {
    res.render("genre_form", { title: "Create Genre" });
    };
    Copy to Clipboard
    Controller—post route
    Find the exported genre_create_post() controller method and replace it with the following code.

    // Handle Genre create on POST.
    exports.genre_create_post = [
    // Validate and sanitize the name field.
    body("name", "Genre name required").trim().isLength({ min: 1 }).escape(),

    // Process request after validation and sanitization.
    (req, res, next) => {
        // Extract the validation errors from a request.
        const errors = validationResult(req);

        // Create a genre object with escaped and trimmed data.
        const genre = new Genre({ name: req.body.name });

        if (!errors.isEmpty()) {
        // There are errors. Render the form again with sanitized values/error messages.
        res.render("genre_form", {
            title: "Create Genre",
            genre,
            errors: errors.array(),
        });
        return;
        } else {
        // Data from form is valid.
        // Check if Genre with same name already exists.
        Genre.findOne({ name: req.body.name }).exec((err, found_genre) => {
            if (err) {
            return next(err);
            }

            if (found_genre) {
            // Genre exists, redirect to its detail page.
            res.redirect(found_genre.url);
            } else {
            genre.save((err) => {
                if (err) {
                return next(err);
                }
                // Genre saved. Redirect to genre detail page.
                res.redirect(genre.url);
            });
            }
        });
        }
    },
    ];
    Copy to Clipboard
    The first thing to note is that instead of being a single middleware function (with arguments (req, res, next)) the controller specifies an array of middleware functions. The array is passed to the router function and each method is called in order.

    Note: This approach is needed, because the validators are middleware functions.

    The first method in the array defines a body validator (body()) that validates and sanitizes the field. This uses trim() to remove any trailing/leading whitespace, checks that the name field is not empty, and then uses escape() to remove any dangerous HTML characters).

    [
    // Validate that the name field is not empty.
    body("name", "Genre name required").trim().isLength({ min: 1 }).escape(),
    // …
    ];
    Copy to Clipboard
    After specifying the validators we create a middleware function to extract any validation errors. We use isEmpty() to check whether there are any errors in the validation result. If there are then we render the form again, passing in our sanitized genre object and the array of error messages (errors.array()).

    // Process request after validation and sanitization.
    (req, res, next) => {
    // Extract the validation errors from a request.
    const errors = validationResult(req);

    // Create a genre object with escaped and trimmed data.
    const genre = new Genre({ name: req.body.name });

    if (!errors.isEmpty()) {
        // There are errors. Render the form again with sanitized values/error messages.
        res.render("genre_form", {
        title: "Create Genre",
        genre,
        errors: errors.array(),
        });
        return;
    } else {
        // Form data is valid.
        // Save the result.
        // …
    }
    };
    Copy to Clipboard
    If the genre name data is valid then we check if a Genre with the same name already exists (as we don't want to create duplicates). If it does, we redirect to the existing genre's detail page. If not, we save the new Genre and redirect to its detail page.

    // Check if Genre with same name already exists.
    Genre.findOne({ name: req.body.name }).exec((err, found_genre) => {
    if (err) {
        return next(err);
    }
    if (found_genre) {
        // Genre exists, redirect to its detail page.
        res.redirect(found_genre.url);
    } else {
        genre.save((err) => {
        if (err) {
            return next(err);
        }
        // Genre saved. Redirect to genre detail page.
        res.redirect(genre.url);
        });
    }
    });
    Copy to Clipboard
    This same pattern is used in all our post controllers: we run validators (with sanitizers), then check for errors and either re-render the form with error information or save the data.

    View
    The same view is rendered in both the GET and POST controllers/routes when we create a new Genre (and later on it is also used when we update a Genre). In the GET case the form is empty, and we just pass a title variable. In the POST case the user has previously entered invalid data—in the genre variable we pass back a sanitized version of the entered data and in the errors variable we pass back an array of error messages.

    res.render("genre_form", { title: "Create Genre" });
    res.render("genre_form", {
    title: "Create Genre",
    genre,
    errors: errors.array(),
    });
    Copy to Clipboard
    Create /views/genre_form.pug and copy in the text below.

    extends layout

    block content
    h1 #{title}

    form(method='POST' action='')
        div.form-group
        label(for='name') Genre:
        input#name.form-control(type='text', placeholder='Fantasy, Poetry etc.' name='name' value=(undefined===genre ? '' : genre.name))
        button.btn.btn-primary(type='submit') Submit

    if errors
    ul
        for error in errors
        li!= error.msg
    Copy to Clipboard
    Much of this template will be familiar from our previous tutorials. First, 
    we extend the layout.pug base template and override the block named 'content'. 
    We then have a heading with the title we passed in from the controller 
    (via the render() method).

    Next, we have the pug code for our HTML form that uses method="POST" to send the 
    data to the server, and because the action is an empty string, will send the data 
    to the same URL as the page.

    The form defines a single required field of type "text" called "name". The 
    default value of the field depends on whether the genre variable is defined. 
    If called from the GET route it will be empty as this is a new form. If called 
    from a POST route it will contain the (invalid) value originally entered by the user.

    The last part of the page is the error code. This prints a list of errors, 
    if the error variable has been defined (in other words, this section will 
    not appear when the template is rendered on the GET route).

    Note: This is just one way to render the errors. You can also get the names 
    of the affected fields from the error variable, and use these to control where 
    the error messages are rendered, whether to apply custom CSS, etc.

    Note: Our validation uses trim() to ensure that whitespace is not accepted 
    as a genre name. We can also validate that the field is not empty on the client 
    side by adding the value required='true' to the field definition in the form:
    {
        input#name.form-control(type='text', placeholder='Fantasy, Poetry etc.' name='name' 
        value=(undefined===genre ? '' : genre.name), required='true' )
    }

    =========== Create Author Form
    First, we need to import express-validator, to use this, we need require the functions we want to use.

    Abrimos /controllers/authorController.js. y agregamos la siguiente linea de código en el top
    {
    const { body, validationResult } = require("express-validator");
    }

    ====== Controller-- get route
    Rellenamos la exportació author_create_get() controller methor y lo reemplazamos con el siguiente coigo.
    {
        // Display Author create form on GET.
        exports.author_create_get = (req, res, next) => {
        res.render("author_form", { title: "Create Author" });
        };

    }

    ===== Controller-- post route
    Rellenamos la exportación author_create_post() con el siguiente código 
    {
        // Handle Author create on POST.
        exports.author_create_post = [
        // Validate and sanitize fields.
        body("first_name")
            .trim()
            .isLength({ min: 1 })
            .escape()
            .withMessage("First name must be specified.")
            .isAlphanumeric()
            .withMessage("First name has non-alphanumeric characters."),
        body("family_name")
            .trim()
            .isLength({ min: 1 })
            .escape()/  / una cadena de validaciones con WithMessage para corroborar el error en cada cosa especificada
            .withMessage("Family name must be specified.")
            .isAlphanumeric()
            .withMessage("Family name has non-alphanumeric characters."),
        body("date_of_birth", "Invalid date of birth")
            .optional({ checkFalsy: true })
            .isISO8601()
            .toDate(),
        body("date_of_death", "Invalid date of death")  
            .optional({ checkFalsy: true }) // Es una validación que se ejecuta sólo si el el campo está lleno 
            .isISO8601()
            .toDate(),
        // Process request after validation and sanitization.
        (req, res, next) => {
            // Extract the validation errors from a request.
            const errors = validationResult(req);

            if (!errors.isEmpty()) {
            // There are errors. Render form again with sanitized values/errors messages.
            res.render("author_form", {
                title: "Create Author",
                author: req.body,
                errors: errors.array(),
            });
            return;
            }
            // Data from form is valid.

            // Create an Author object with escaped and trimmed data.
            const author = new Author({
            first_name: req.body.first_name,
            family_name: req.body.family_name,
            date_of_birth: req.body.date_of_birth,
            date_of_death: req.body.date_of_death,
            });
            author.save((err) => {
            if (err) {
                return next(err);
            }
            // Successful - redirect to new author record.
            res.redirect(author.url);
            });
        },
        ];

    }

    Warning: Never validate names using isAlphanumeric() (as we have done above) as there are 
    many names that use other character sets. We do it here in order to demonstrate how the validator 
    is used, and how it can be daisy-chained with other validators and error reporting


    We can use the optional() function to run a subsequent validation only if a field has been entered 
    (this allows us to validate optional fields). For example, below we check that the optional date 
    of birth is an ISO8601-compliant date (the checkFalsy flag means that we'll accept either an empty 
    string or null as an empty value).

    ====== VIEW 
    views/author_form.pug
    {
        extends layout

        block content
        h1=title

        form(method='POST' action='')
            div.form-group
            label(for='first_name') First Name:
            input#first_name.form-control(type='text' placeholder='First name' name='first_name' required='true' value=(undefined===author ? '' : author.first_name) )
            label(for='family_name') Family Name:
            input#family_name.form-control(type='text' placeholder='Family name' name='family_name' required='true' value=(undefined===author ? '' : author.family_name))
            div.form-group
            label(for='date_of_birth') Date of birth:
            input#date_of_birth.form-control(type='date' name='date_of_birth' value=(undefined===author ? '' : author.date_of_birth) )
            label(for='date_of_death') Date of death:
            input#date_of_death.form-control(type='date' name='date_of_death' value=(undefined===author ? '' : author.date_of_death) )
            button.btn.btn-primary(type='submit') Submit
        if errors
            ul
            for error in errors
                li!= error.msg

    }

    Lo unico diferente comparado con el genre_form es que acá posemos un type="date", para que se ponga correctamente
    la fecha. También se podría poner un placeholder="dd/mm/yyyy" para indicar en qué formato tiene que poner la fecha


    ============= Create Book FORM CRUD formulario
    This subarticle shows how to define a page/form to create Book objects. 
    This is a little more complicated than the equivalent Author or Genre pages 
    because we need to get and display available Author and Genre records in our Book form.

    ===== Import validation and sanitzation method
    /controllers/bookController.js
    {
        const { body, validationResult } = require("express-validator");
    }


    ===0== Controller - get route
    Primero exportamos book_create_get() controller method y lo reemplazamos con el siguiente codigo
    {
        // Display book create form on GET.
        exports.book_create_get = (req, res, next) => {
        // Get all authors and genres, which we can use for adding to our book.
        async.parallel(
            {
            authors(callback) {
                Author.find(callback);
            },
            genres(callback) {
                Genre.find(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            res.render("book_form", {
                title: "Create Book",
                authors: results.authors,
                genres: results.genres,
            });
            }
        );
        };


    }

    Esto usa el modulo async ( describido en la parte 5 del tutuorial) para tener todos los authores y generos. Estos
    son pasado para la vista de book_form.pug como ariables llamadas authors y genres (junto con la page title )

    ========== Controller -- post route
    Primero exportamos book_create_bpost() controller method y lo reemplazamos con el siguiente codigo.
    {
        // Handle book create on POST.
        exports.book_create_post = [ // Primero tenemos que recoradr que routes acepta como primer parametro el path
                                    // y el segundo puede ser un array de middlewares, y esto es lo que hacemos 
        // Convert the genre to an array.
        (req, res, next) => { //Lo convertimos en array porque recordemos que el modelo de Books guarda un array de generos
            if (!Array.isArray(req.body.genre)) {
            req.body.genre =
                typeof req.body.genre === "undefined" ? [] : [req.body.genre];
            }
            next();
        },

        // Validate and sanitize fields. // Realizamos las validaciones 
        body("title", "Title must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("author", "Author must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("summary", "Summary must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("isbn", "ISBN must not be empty").trim().isLength({ min: 1 }).escape(),
        body("genre.*").escape(),

        // Process request after validation and sanitization.
        (req, res, next) => { 
            // Extract the validation errors from a request.
            const errors = validationResult(req); // Toma los resultados de antes y ve si recibe algun error

            // Create a Book object with escaped and trimmed data.
            const book = new Book({
            title: req.body.title,
            author: req.body.author,
            summary: req.body.summary,
            isbn: req.body.isbn,
            genre: req.body.genre,
            });

            if (!errors.isEmpty()) {
            // There are errors. Render form again with sanitized values/error messages.

            // Get all authors and genres for form.
            async.parallel(
                {
                authors(callback) {
                    Author.find(callback);
                },
                genres(callback) {
                    Genre.find(callback);
                },
                },
                (err, results) => {
                if (err) {
                    return next(err);
                }

                // Mark our selected genres as checked.
                for (const genre of results.genres) {
                    if (book.genre.includes(genre._id)) {
                    genre.checked = "true";
                    }
                }
                res.render("book_form", {
                    title: "Create Book",
                    authors: results.authors,
                    genres: results.genres,
                    book,
                    errors: errors.array(),
                });
                }
            );
            return;
            }

            // Data from form is valid. Save book.
            book.save((err) => {
            if (err) {
                return next(err);
            }
            // Successful: redirect to new book record.
            res.redirect(book.url);
            });
        },
        ];

    }

    The structure and behavior of this code is almost exactly the same as for creating a Genre or Author object. 
    First we validate and sanitize the data. If the data is invalid then we re-display the form along with 
    the data that was originally entered by the user and a list of error messages. If the data is valid, 
    we then save the new Book record and redirect the user to the book detail page.


    The main difference with respect to the other form handling code is how we sanitize the genre information. 
    The form returns an array of Genre items (while for other fields it returns a string). 
    In order to validate the information we first convert the request to an array (required for the next step)

    {
        [
        // Convert the genre to an array.
        (req, res, next) => {
            if (!Array.isArray(req.body.genre)) {
            req.body.genre =
                typeof req.body.genre === "undefined" ? [] : [req.body.genre];
            }
            next();
        },
        // …
        ];

    }
    We then use a wildcard (*) in the sanitizer to individually validate each of the genre array entries. 
    The code below shows how - this translates to "sanitize every item below key genre".
    [
    // …
    body("genre.*").escape(),
    // …
    ];

    The final difference with respect to the other form handling code is that we need to pass in all existing 
    genres and authors to the form. In order to mark the genres that were checked by the user we iterate 
    through all the genres and add the checked='true' parameter to those that were in our post data 
    (as reproduced in the code fragment below).
    {
        // Mark our selected genres as checked.
        for (const genre of results.genres) {
        if (book.genre.includes(genre._id)) {
            // Current genre is selected. Set "checked" flag.
            genre.checked = "true";
        }
        }

    }
    ===== VIEW
    /views/book_form.pug y copiamos el texto de debajo 
    {
        extends layout

        block content
        h1= title

        form(method='POST' action='')
            div.form-group
            label(for='title') Title:
            input#title.form-control(type='text', placeholder='Name of book' name='title' required='true' value=(undefined===book ? '' : book.title) )
            div.form-group
            label(for='author') Author:
            select#author.form-control(type='select', placeholder='Select author' name='author' required='true' )
                - authors.sort(function(a, b) {let textA = a.family_name.toUpperCase(); let textB = b.family_name.toUpperCase(); return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;});
                for author in authors
                if book
                    option(value=author._id selected=(author._id.toString()===book.author._id.toString() ? 'selected' : false) ) #{author.name}
                else
                    option(value=author._id) #{author.name}
            div.form-group
            label(for='summary') Summary:
            textarea#summary.form-control(type='textarea', placeholder='Summary' name='summary' required='true') #{undefined===book ? '' : book.summary}
            div.form-group
            label(for='isbn') ISBN:
            input#isbn.form-control(type='text', placeholder='ISBN13' name='isbn' value=(undefined===book ? '' : book.isbn) required='true')
            div.form-group
            label Genre:
            div
                for genre in genres
                div(style='display: inline; padding-right:10px;')
                    input.checkbox-input(type='checkbox', name='genre', id=genre._id, value=genre._id, checked=genre.checked )
                    label(for=genre._id) #{genre.name}
            button.btn.btn-primary(type='submit') Submit

        if errors
            ul
            for error in errors
                li!= error.msg

    }

    The view structure and behavior is almost the same as for the genre_form.pug template.

    The main differences are in how we implement the selection-type fields: Author and Genre.

        - The set of genres are displayed as checkboxes, using the checked value we set in the 
    controller to determine whether or not the box should be selected.
        - The set of authors are displayed as a single-selection alphabetically ordered drop-down list. 
    If the user has previously selected a book author (i.e. when fixing invalid field values 
    after initial form submission, or when updating book details) the author will be 
    re-selected when the form is displayed. Here we determine what author to select by comparing 
    the id of the current author option with the value previously entered by the user (passed in via 
    the book variable). This is highlighted above!

    {
        Note: If there is an error in the submitted form, then, when the form is to be re-rendered,
        the new book author's id and the existing books's authors ids are of type Schema.Types.ObjectId.
        So to compare them we must convert them to strings first.
    }




    ========================= Create BooKiNSTANCE FORM
    This subarticle shows how to define a page/form to create BookInstance objects. 
    This is very much like the form we used to create Book objects.

    ======== Import validation y sanitazión methor
    en controllers/bookinstance.js importamos los sig metodos de express-validator

    const { body, validationResult } = require("express-validator");


    ========= Controller -get route
    En el top del archivo, requerimos el Book module ( lo necesitamo porque cada BookInstance es asociado
    con un libro en particular)

    {
        const Book = require("../models/book");
    }

    Reemplazamos bookinstance_create_get() controller method y reemplazamo con el siguiente codigo:
    {
        // Display BookInstance create form on GET.
        exports.bookinstance_create_get = (req, res, next) => {
        Book.find({}, "title").exec((err, books) => {
            if (err) {
            return next(err);
            }
            // Successful, so render.
            res.render("bookinstance_form", {
            title: "Create BookInstance",
            book_list: books,
            });
        });
        };

    }

    El controlador obtiene un alista de todos los libros (book_list) y pasa esto a las vistas bookinstance_form.pug
    (también title)

    ======= Controller - post route POST
    Rellenamos bookinstance_create_post() cibtrikker nethiw y lo reeplazamos con el siguiente código
    {
        // Handle BookInstance create on POST.
        exports.bookinstance_create_post = [
        // Validate and sanitize fields.
        body("book", "Book must be specified").trim().isLength({ min: 1 }).escape(),
        body("imprint", "Imprint must be specified")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("status").escape(),
        body("due_back", "Invalid date")
            .optional({ checkFalsy: true })
            .isISO8601()
            .toDate(),

        // Process request after validation and sanitization.
        (req, res, next) => {
            // Extract the validation errors from a request.
            const errors = validationResult(req);

            // Create a BookInstance object with escaped and trimmed data.
            const bookinstance = new BookInstance({
            book: req.body.book,
            imprint: req.body.imprint,
            status: req.body.status,
            due_back: req.body.due_back,
            });

            if (!errors.isEmpty()) {
            // There are errors. Render form again with sanitized values and error messages.
            Book.find({}, "title").exec(function (err, books) {
                if (err) {
                return next(err);
                }
                // Successful, so render.
                res.render("bookinstance_form", {
                title: "Create BookInstance",
                book_list: books,
                selected_book: bookinstance.book._id,
                errors: errors.array(),
                bookinstance,
                });
            });
            return;
            }

            // Data from form is valid.
            bookinstance.save((err) => {
            if (err) {
                return next(err);
            }
            // Successful: redirect to new record.
            res.redirect(bookinstance.url);
            });
        },
        ];

    }

    La estructura y el comportamiento de este codigo es el mismo como creamos nuestros otros objetos. Primero 
    validamos y sanitizamos la data. Si esta data es incalida, nosotros re mostrarmos el formuladrio
    a travez con la data que fue intentando entrar originalmente por el usuario y una lista con el mensaje de error.
    Si la data es valid, nosotros guardamos la nueva bookInsatance y redireccionamos al usuario a su detail page.

    ==== VIEWCreamos /view/bookinstance_form.pug y copiamos el texto de abajo

    {
        extends layout

        block content
        h1=title

        form(method='POST' action='')
            div.form-group
            label(for='book') Book:
            select#book.form-control(type='select' placeholder='Select book' name='book' required='true')
                - book_list.sort(function(a, b) {let textA = a.title.toUpperCase(); let textB = b.title.toUpperCase(); return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;}); // sort orena el documento
                for book in book_list
                option(value=book._id, selected=(selected_book==book._id.toString() ? 'selected' : false) ) #{book.title}

            div.form-group
            label(for='imprint') Imprint:
            input#imprint.form-control(type='text' placeholder='Publisher and date information' name='imprint' required='true' value=(undefined===bookinstance ? '' : bookinstance.imprint))
            div.form-group
            label(for='due_back') Date when book available:
            input#due_back.form-control(type='date' name='due_back' value=(undefined===bookinstance ? '' : bookinstance.due_back))

            div.form-group
            label(for='status') Status:
            select#status.form-control(type='select' placeholder='Select status' name='status' required='true')
                option(value='Maintenance') Maintenance
                option(value='Available') Available
                option(value='Loaned') Loaned
                option(value='Reserved') Reserved

            button.btn.btn-primary(type='submit') Submit

        if errors
            ul
            for error in errors
                li!= error.msg


    }
    La estructura y estilo es bastante parecido a book_form.pug template, entonces no la cubriremos otra vez



    =========================== DELETE AUTHOR FORM
    Este subarticle muestra como definir la pagina para borrar los objetos de author

    As discussed in the form design section, our strategy will be to only allow deletion 
    of objects that are not referenced by other objects (in this case that means we won't 
    allow an Author to be deleted if it is referenced by a Book). In terms of implementation 
    this means that the form needs to confirm that there are no associated books before the 
    author is deleted. If there are associated books, it should display them, and state
    that they must be deleted before the Author object can be deleted.

    ============ Controller get-router delete 
    abrimos contrllers/authorController y rellenamos donde dice author_delete_get()
    {
        // Display Author delete form on GET.
        exports.author_delete_get = (req, res, next) => {
        async.parallel(
            {
            author(callback) {
                Author.findById(req.params.id).exec(callback);
            },
            authors_books(callback) {
                Book.find({ author: req.params.id }).exec(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            if (results.author == null) {
                // No results.
                res.redirect("/catalog/authors");
            }
            // Successful, so render.
            res.render("author_delete", {
                title: "Delete Author",
                author: results.author,
                author_books: results.authors_books,
            });
            }
        );
        };

    }

    The controller gets the id of the Author instance to be deleted from the URL parameter (req.params.id). 
    It uses the async.parallel() method to get the author record and all associated books in parallel. 
    When both operations have completed it renders the author_delete.pug view, passing variables for the 
    title, author, and author_books.

    Note: If findById() returns no results the author is not in the database. In this case there is nothing 
    to delete, so we immediately render the list of all authors.

    (err, results) => {
        if (err) {
        return next(err);
        }
        if (results.author == null) { // No results.
        res.redirect('/catalog/authors');
        }
    Copy to Clipboard

    ============== Controller - post route
    rellenamos author_delete_post() 
    {
        // Handle Author delete on POST.
        exports.author_delete_post = (req, res, next) => {
        async.parallel(
            {
            author(callback) {
                Author.findById(req.body.authorid).exec(callback);
            },
            authors_books(callback) {
                Book.find({ author: req.body.authorid }).exec(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            // Success
            if (results.authors_books.length > 0) {
                // Author has books. Render in same way as for GET route.
                res.render("author_delete", {
                title: "Delete Author",
                author: results.author,
                author_books: results.authors_books,
                });
                return;
            }
            // Author has no books. Delete object and redirect to the list of authors.
            Author.findByIdAndRemove(req.body.authorid, (err) => {
                if (err) {
                return next(err);
                }
                // Success - go to author list
                res.redirect("/catalog/authors");
            });
            }
        );
        };

    }

    First we validate that an id has been provided (this is sent via the form body parameters, 
    rather than using the version in the URL). Then we get the author and their associated 
    books in the same way as for the GET route. If there are no books then we delete the author 
    object and redirect to the list of all authors. If there are still books then we just re-render 
    the form, passing in the author and list of books to be deleted.

    Note: We could check if the call to findById() returns any result, and if not, immediately 
    render the list of all authors. We've left the code as it is above for brevity (it will 
    still return the list of authors if the id is not found, but this will happen after 
    findByIdAndRemove()).

    ===== VIEW 
    Creamos /views/author_delete.pug y copiamos el texto de debajo
    {
        extends layout

        block content
        h1 #{title}: #{author.name}
        p= author.lifespan

        if author_books.length

            p #[strong Delete the following books before attempting to delete this author.]

            div(style='margin-left:20px;margin-top:20px')

            h4 Books

            dl
            each book in author_books
                dt
                a(href=book.url) #{book.title}
                dd #{book.summary}

        else
            p Do you really want to delete this Author?

            form(method='POST' action='')
            div.form-group
                input#authorid.form-control(type='hidden',name='authorid', required='true', value=author._id )

            button.btn.btn-primary(type='submit') Delete

    }
    The view extends the layout template, overriding the block named content. 
    At the top it displays the author details. It then includes a conditional 
    statement based on the number of author_books (the if and else clauses).

        - If there are books associated with the author then the page lists the books 
    and states that these must be deleted before this Author may be deleted.
        - If there are no books then the page displays a confirmation prompt.
        - If the Delete button is clicked then the author id is sent to the server in a 
    POST request and that author's record will be deleted.

    ======= Añadimos el controll de delete
    Necesitamos agregar el delete control en la vissta de author detail (the detail page is a good place form which to delete
    a record)

    Note: In a full implementation the control would be made visible only to authorized users. 
    However at this point we haven't got an authorization system in place!

    Abrimos el author_detail.pug y agregamos las siguientes lineas en la parte de debajo 
    {
        hr
        p
        a(href=author.url+'/delete') Delete author
    }


    ======================== Update Book Form
    Este subarticulo ginal muestra como definir la pagina para actualizar los objetos books. 
    Form handling when updating a book is much like that for creating a book, except that you 
    must populate the form in the GET route with values from the database.

    ===== Controller - get route
    Abrimos /controllers/bookController. Y rellenamos la exportación book_update_get() controller method
    y lo reemplazamos con esto: 
    {
        // Display book update form on GET.
        exports.book_update_get = (req, res, next) => {
        // Get book, authors and genres for form.
        async.parallel(
            {
            book(callback) {
                Book.findById(req.params.id)
                .populate("author")
                .populate("genre")
                .exec(callback);
            },
            authors(callback) {
                Author.find(callback);
            },
            genres(callback) {
                Genre.find(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            if (results.book == null) {
                // No results.
                const err = new Error("Book not found");
                err.status = 404;
                return next(err);
            }
            // Success.
            // Mark our selected genres as checked.
            for (const genre of results.genres) {
                for (const bookGenre of results.book.genre) {
                if (genre._id.toString() === bookGenre._id.toString()) {
                    genre.checked = "true";
                }
                }
            }
            res.render("book_form", {
                title: "Update Book",
                authors: results.authors,
                genres: results.genres,
                book: results.book,
            });
            }
        );
        };

    }
    The controller gets the id of the Book to be updated from the URL parameter (req.params.id). 
    It uses the async.parallel() method to get the specified Book record (populating its genre and 
    author fields) and lists of all the Author and Genre objects.

    When the operations complete it checks for any errors in the find operation, and also 
    whether any books were found.

    Note: Not finding any book results is not an error for a search — but it is for this 
    application because we know there must be a matching book record! The code above compares 
    for (results==null) in the callback, but it could equally well have daisy chained the method 
    orFail() to the query.

    We then mark the currently selected genres as checked and then render the book_form.pug 
    view, passing variables for title, book, all authors, and all genres.

    =============== Controller - post route UPDATE BOOK
    Ponemos en book_update_post() controller method el siguiente codigo: 
    {
            // Handle book update on POST.
        exports.book_update_post = [
        // Convert the genre to an array
        (req, res, next) => {
            if (!Array.isArray(req.body.genre)) {
            req.body.genre =
                typeof req.body.genre === "undefined" ? [] : [req.body.genre];
            }
            next();
        },

        // Validate and sanitize fields.
        body("title", "Title must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("author", "Author must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("summary", "Summary must not be empty.")
            .trim()
            .isLength({ min: 1 })
            .escape(),
        body("isbn", "ISBN must not be empty").trim().isLength({ min: 1 }).escape(),
        body("genre.*").escape(),

        // Process request after validation and sanitization.
        (req, res, next) => {
            // Extract the validation errors from a request.
            const errors = validationResult(req);

            // Create a Book object with escaped/trimmed data and old id.
            const book = new Book({
            title: req.body.title,
            author: req.body.author,
            summary: req.body.summary,
            isbn: req.body.isbn,
            genre: typeof req.body.genre === "undefined" ? [] : req.body.genre,
            _id: req.params.id, //This is required, or a new ID will be assigned!
            });

            if (!errors.isEmpty()) {
            // There are errors. Render form again with sanitized values/error messages.

            // Get all authors and genres for form.
            async.parallel(
                {
                authors(callback) {
                    Author.find(callback);
                },
                genres(callback) {
                    Genre.find(callback);
                },
                },
                (err, results) => {
                if (err) {
                    return next(err);
                }

                // Mark our selected genres as checked.
                for (const genre of results.genres) {
                    if (book.genre.includes(genre._id)) {
                    genre.checked = "true";
                    }
                }
                res.render("book_form", {
                    title: "Update Book",
                    authors: results.authors,
                    genres: results.genres,
                    book,
                    errors: errors.array(),
                });
                }
            );
            return;
            }

            // Data from form is valid. Update the record.
            Book.findByIdAndUpdate(req.params.id, book, {}, (err, thebook) => {
            if (err) {
                return next(err);
            }

            // Successful: redirect to book detail page.
            res.redirect(thebook.url);
            });
        },
        ];

    }

    This is very similar to the post route used when creating a Book. 
    First we validate and sanitize the book data from the form 
    and use it to create a new Book object (setting its _id value 
    to the id of the object to update). If there are errors when 
    we validate the data then we re-render the form, additionally 
    displaying the data entered by the user, the errors, and lists 
    of genres and authors. If there are no errors then we call Book.findByIdAndUpdate() 
    to update the Book document, and then redirect to its detail page.

    ====== VIEW 
    PARA ESTE NO CREAMOS UNA NUEVA VIEW, SÓLO CAMBIAMOS UNA COSA DEL BOOK_FORM DE ANTES
    Abrimos /view/book_form.pug y actualizamos la sección dibde ek author form control esta poniendo el codigo
    condicional mostrado abajo 
    {
        div.form-group
        label(for='author') Author:
        select#author.form-control(type='select' placeholder='Select author' name='author' required='true' )
            - authors.sort(function(a, b) {let textA = a.family_name.toUpperCase(); let textB = b.family_name.toUpperCase(); return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;});
            for author in authors
            if book
                //- Handle GET form, where book.author is an object, and POST form, where it is a string.
                option(
                value=author._id
                selected=(
                    author._id.toString()==book.author._id
                    || author._id.toString()==book.author //la ÚNICA DIFERENCIA, ES ESTA. 
                ) ? 'selected' : false
                ) #{author.name}
            else
                option(value=author._id) #{author.name}

    }

    Note: This code change is required so that the book_form can be used for both creating 
    and updating book objects (without this, there is an error on the GET route when creating a form).


    =========== Añadimos un boton de actualizar UPDATE button
    Open the book_detail.pug view and make sure there are links for both 
    deleting and updating books at the bottom of the page, as shown below. 

    {
        hr
        p
            a(href=book.url+'/delete') Delete Book
        p
            a(href=book.url+'/update') Update Book

    }


    =============================== Challenge yourself
    Implement the delete pages for the Book, BookInstance, and Genre models, linking them 
    from the associated detail pages in the same way as our Author delete page. The pages should
    follow the same design approach:

    - if there are referencie to the objtect form other object,  then thse other object should be
    displayed along with a note that this record can't be deleted until the listed objects have
    been deleted.

    - If there are no other reference to the object then the view should prompt to delete it. If the user
    presses the delete button, the record hould then be deleted.

    A few tips.

        - Deleting a Genre is just like deleting an Author as both objects are dependencies of Book (so in both
        cases you can delete the object only when the associated books are deleted).
        - Deleting a Book is also similar, but you need to check that there are no associated BookInstance.
        - Deleting BookInstance is the easiest of all because there are no dependent object. In this case,
        you can just find the associated record and delete it. 

    Implementhe the update pages for the BookInstance, Author, and Genre models, linking them from the associated detail pages
    in the same way as our Book update page.

    A few tips:

        - The book update page we just implemented is the hardest! The same patterns can be used for
        the update pages for the other objects.
        - The Author date of death and date of birth fields and the BookInstance due_Date field are
        the wrong format to input into the date input field on the format ( it requires data in form "yyyy-mm-dd").
        The easiest way to get around this is to define a new virtual propery for the dates that formats the dates
        appropriately, and then use this field in the associated view templates. 

    i did this with the following code
    {
        BookInstanceSchema.virtual("due_back_yyyy_mm_dd").get(function () {
        return DateTime.fromJSDate(this.due_back).toISODate();
        })
    }

    is most similar as "due_back_formatted", but the only diference is that after (this.due_back) y put ".toISODate()" to 
    changue it to ISODATE() instead of toLocalString() 


    ============= DELETE BOOKINSTANCE 

    ====== CONTROLLER GET MEHOT Export
    {
        
        // Display BookInstance delete form on GET.
        exports.bookinstance_delete_get = (req, res, next) => {
        BookInstance.findById(req.params.id)
            .populate("book")
            .exec((err, bookinstance) => {
            if (err) {
                return next(err);
            }
            if(bookinstance == null){
                res.redirect("/catalog/bookinstances");
            }
            res.render("bookinstance_delete", {
                title: "Delete Bookinstance",
                bookinstance,
            })
        })
        
        };
    }

    ============ CONTROLLER POST METHOD Export
    {
        // Handle BookInstance delete on POST.
        exports.bookinstance_delete_post = (req, res, next) => {
            BookInstance.findByIdAndRemove(req.body.bookinstanceid, (err)=>{
            if (err) {
                return next(err);
            }
            res.redirect("/catalog/bookinstances");
            });
        };
    }

    ===== view
    {
        extends layout 

        block content 
        h1 #{title}: #{bookinstance.book.title}
        p= bookinstance.imprint 

        p Do you really want to delete this Bookinstance?

        form(method="POST" action='')
            div.form-group 
            input#bookinstanceid.form-control(type="hidden", name="bookinstanceid", required="true", value=bookinstance._id)
            button.btn.btn-primary(type='submit') Delete
    }

    ====== Añadimos a bookisntnace detail 
    {
        hr
        p
            a(href=bookinstance.url+'/delete') Delete bookinstance
        p
            a(href=bookinstance.url+'/update') Update bookinstance

    }

    ========= Genre DELETE 
    ===== Controllers
    {
        
        // Display Genre delete form on GET.
        exports.genre_delete_get = (req, res, next ) => {
        async.parallel(
            {
            genre(callback){
                Genre.findById(req.params.id).exec(callback);
            },
            genre_books(callback) {
                Book.find({ genre: req.params.id }).exec(callback);
            }
            },
        (err, results) => {
            if (err) {
            return next(err);
            }
            if (results.genre == null){
            // No results.
            res.redirect("/catalog/genres")
            }
            res.render("genre_delete",{
            title : "Delete Genre",
            genre : results.genre,
            genre_books : results.genre_books,
            });
        });
        };

        // Handle Genre delete on POST.
        exports.genre_delete_post = (req, res) => {
        async.parallel(
            {
            genre(callback){
                Genre.findById(req.params.genreid).exec(callback);
            },
            genre_books(callback) {
                Book.find({ genre: req.params.genreid }).exec(callback);
            }
            },
        (err, results) => {
            if (err) {
            return next(err);
            }
            if (results.genre_books.isLength > 0 ){
            res.render("genre_delete", {
                title:"Delete genre",
                genre: results.genre,
                genre_books : results.genre_books,
            });
            return;
            }

            Genre.findByIdAndRemove(req.body.genreid, (err) => {
            if (err){
                return next(err);
            }

            res.redirect("/catalog/genres")
            })
        });
        };
    }

    ===== VIEW
    extends layout 

    block content 
    h1 #{title}: #{genre.name}
    
    if genre_books.length 

        p #[strong Delete or update the following books before attempting to delete this author]

        div(style="margin-left:20px;margin-top:20px")

        h4 Books 

        dl 
        each book in genre_books
            dt 
            a(href=book.url) #{book.title}
            dd #{book.summary}
    else 
        p Do you really want to delete this Genre?

        form(method="POST" action="")
            div.form-group 
            input#genreid.form-control(type='hidden',name='genreid', required='true', value=genre._id ) 
            button.btn.btn-primary(type="submit") Delete 

    ====== Añadimos a GENRE detail 
    {
        hr
        p
            a(href=genre.url+'/delete') Delete genre
        p
            a(href=genre.url+'/update') Update genre




    ============== Book Delete 
    Para este requerimos de los bookinstance porque estos son dependientes de los
    books para implementarse. Por lo que debemos trabajar con estos, es
    lo mismo que hacemos con los demás, sólo que trabajando con Book y bookinstance

    ============ Controllers 
    {
            // Display book delete form on GET.
        exports.book_delete_get = (req, res, next) => {
        async.parallel(
            {
            book(callback){
                Book.findById(req.params.id)
                .populate("author")
                .populate("genre")
                .exec(callback);
            },
            bookinstances(callback){
                BookInstance.find({book: req.params.id}).exec(callback);
            },
            },
            (err, results) => {
            if (err){
                return next(err);
            }
            if(results.book == null){
                res.redirect("/catalog/books");
            }
            res.render("book_delete", {
                title: "Delete Book",
                book : results.book,
                bookinstances : results.bookinstances,
            });
            }
        );
        };

        // Handle book delete on POST.
        exports.book_delete_post = (req, res, next) => {
        async.parallel(
            {
            book(callback){
                Book.findById(req.body.bookid)
                .populate("author")
                .populate("genre")
                .exec(callback);
            },
            bookinstances(callback){
                BookInstance.find({book: req.body.bookid}).exec(callback); // Acá realmente se podría usar el body.bookid o el params.id
                // pero lo ponemos asi porque sino desde la pestaña get podríamos modificar la url, cambiar el id, y eliminar otra cosa que no deberíamos
                // o causar un error, esto es una prevención, bastante god
            },
            },
            (err,results) => {
            if(err){
                return next(err)
            }
            if(results.bookinstances.length > 0){
                res.render("book_delete", {
                Title: "Delete Book",
                book : results.book,
                bookinstances : results.bookinstances,
            });
            return;
            } else {
            // Book has no bookinstance. Delete object and redirect to the list of books
            Book.findByIdAndRemove(req.body.bookid, (err) => {
            if (err){
                return next(err);
            }
            res.redirect("/catalog/books")     
            });
            }
        }
        )
        };
    }

    ============= VIEW 
    {
        extends layout

        block content

        h1 #{title}: #{book.title}
        
        p #[strong Author:] 
            a(href=book.author.url) #{book.author.name}
        p #[strong Summary:] #{book.summary}
        p #[strong ISBN:] #{book.isbn}
        p #[strong Genre:] 
            each val in book.genre
            a(href=val.url) #{val.name}
            |, 

        hr
        
        if bookinstances.length
        
            p #[strong Delete the following copies before attempting to delete this Book.]
        
            div(style='margin-left:20px;margin-top:20px')

            h4 Copies
            
            each book_copy in bookinstances
                hr
                if book_copy.status=='Available'
                p.text-success #{book_copy.status}
                else if book_copy.status=='Maintenance'
                p.text-danger #{book_copy.status}
                else
                p.text-warning #{book_copy.status} 
                p #[strong Imprint:] #{book_copy.imprint}
                if book_copy.status!='Available'
                p #[strong Due back:] #{book_copy.due_back}
                p #[strong Id:] 
                a(href=book_copy.url) #{book_copy._id}

        else
            p Do you really want to delete this Book?
            
            form(method='POST' action='')
            div.form-group
                input#bookid.form-control(type='hidden',name='bookid', required='true', value=book._id )

            button.btn.btn-primary(type='submit') Delete
    }



    ===========================
    Todo después de esto no lo documenté, me faltan actualizar los update

    lo que si arreglé un pequeñito error. Cuando cometía un error al actualizar un producto,
    luego se arreglaba, y se volvía a la pestaña de actualizar, se quedaban
    dos li (dos puntos) vacios debajos que quedaban muy feos, por lo que debajo de 
    cada 
    each error in error

    use un condicional, quedando así: 

    {
        if errors
            ul
                for error in errors
                if error != "" && error != "error => error"
                    li!= error.msg
    }
    Esto lo modifique en todos los form 



    =============================================================================================================
    ====================================== S U M M A R Y 
    Express, node, and third-party packages on npm provide everything you need to add 
    forms to your website. In this article, you've learned how to create forms using Pug, 
    validate and sanitize input using express-validator, and add, delete, and modify records in the database.

    You should now understand how to add basic forms and form-handling code to your own node websites

    SEE also
    express-validator
]

    ==== lanzamiento a P R O D U C C I Ó N ====
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/deployment

Now yo´ve created (and tested) an awesome LocalLibrary website, you´re going to want to install it on 
a public web server so that it can be accessed by library staff and members over the internet.
This article proves an overview of how you might go aboit finding a host to deploy your website,
and what you need to do in order to get tour site ready for production.

Objective: To learn where and how you can deplot an Express ap to production.

============================= Overiew =======================
Once your site is finished (or finished "enough" to start public testing) you´re going to need
to host it somewhere more public and accessible than your personal development computer.

Up to now, you've been working in devolement environment, using Express/Node as a web server
to share your site to the local browser/network, and running your website with (insecure)
development settings that expose debugging and other private information. Before you can host a website externally
you´re first going to have:

    - Choose an enviroment for hosting Express app.
    - Make a few changes to yout project settings.
    - Set up a production-level for serving your website.

This tutorial provides some guidance on your options for choosing a hosting site, a brief overview of
what you need to do in order to get your Express app ready for production, and a working example 
of how to install the LocalLibrary website onto the Railway cloud hosting service. 

Note: Railway is an ingraestructure platform where you can provision infraestrctire, develop with that
infraestrcture locally, and then deploy to the cloud.

============ What is a production enviroment? 
The production enviroment is the enviroment provided by the server computer where you will run
your website for external consumption. The enviroment includes:
    - Computer hardware on which the website runs.
    - Operating system (e.g. Linuz or Windows).
    - Programming language runtime and framework libraries on top of which your website is written.
    - Web server infarstructure, possibly including a web server, reverse proxy, load balancer, etc.
    - Databases on which your website is dependent. 

===== Infraestructure as a Service (IaaS)
The server computer could be located on your premises and connected to the internet by a fast link,
but it's far more common to use a computer that is hoster "in the cloud": What this actually mean is
that your code is run on some remote computer (or possibly a "virtual" computer) inyour hosting
company's data center(s). The remote server will usually offer some guaranted level of computing
resorce(e.g. CPU, RAM, storage memory, etc.) and internet connectivy for a certain price.

This sort of remotely accesible computing/networking hardware is referred to as infraestrcture as a 
Service (IaaS). Many IaaS vendors provide options to preinstall a particular operating system, onto
which you must install the other component of your production enviroment. Other vendedos allow
you to selec more fully-featured enviroments, perhaps (tal vez) including a complete Node setup.

Note: pre-built enviroment can make setting up your website very easy because they reduce the configuration,
but the available options may limit you to an unfamiliar server (or other components) and may be base on an older
version of the OS. Often it's better to install components yourself so that you get the ones that you want,
and when you need to upgrade parts of the system, you have some idea of where you start!

=========== Platform as a Service (PaaS)
Other hosting providers support Express as part of Platform as a Service (PaaS) offering. When using
this sort of hosting you dont need to worry about most of your producion enviroment  (servers, load balancers, etc)
as the host platform takes care of those for you ( :D ). That makes deployment quite easy because you just need to 
concentrate on your web application and noy any other server infraestructure.

Some developers will choose the increased flexibility provide by IaaS over PaaS, while others will 
appreciate the reduced maintance overhead and easier scaling of PaaS. When you're getting started, setting up
your website on a PaaS sysyem is much easier, so that is what we'll do in this tutorial.

--------------
Note: If you choose a Node/Express-friendly provider they should provide intrusction on how
to set up an Express website using different configurations of web server, application server, reverse proxt, Etc.
For example, there are many step-by-step guides for various configurations in the Digital Ocean Node community docs.
--------------



======================= Choosing a hosting provider =========================
There are numerous hosting providers that are known to either actively support or work well with 
Node (and Express). These vendedors provide different types of enviroments (Iass, PaaS) and different
levels of computing and network resources at different prices.

Note: there are a lot of hosting solutions, and their services and pricing can change over time. 
While we introduce a few options below, it0s woth cheking both these and other options before
selecting a hosting provider.

Some of the things to consider when choosing a host:
    - How busy your site it likely ro be and the cost of data computing resoruces required to meet that
    demand.
    - Level of support for scaling horizontally (adding more machines) and vertically (upgrading to more powerful machines)
    and the costs of doing so.
    - The locations that the supplier has data centers, and hence where acces is likely to be fast. 
    - The host's historical uptime and downtime performance.
    - Tools provide for managing the site - are they easy to use and are they secure (e.j SFTP vs FTP ) Note:
    an FTP (File Transfer Protocol) is a standart comunication protocol used for the transfer of computer files from a server to a client
    on a computer network
    - Inbuilt frameworks for monitoring your server
    - Known limitations. Some hosts will deliberately block sertan services (e.g. email). Others offer
    only a certain number of hours of "live time" in some proce tiers, or only offer a small amount of storage.
    - Additional benefits. Some provider will offer free domain names and support for SSL certificates
    that you would otherwise have to pay for. Note: SSL certificate, Secure Sockets Later is a standard security technology
    for establishing an encrypted link between a server and a client-- Tipically a web server (website) and browser, or a mail 
    server and a mail client(e.g. Outlook)
    - Whether the "free" tier you're relying on expires over time, and whether the cost of migrating to a more
    expensive tier means you would have been better off using some other service in the first place!


The good news when you're starting out is that there are quite a frew sites that provie "free" 
computing enviroments that are intended for evaluation and testint. These are usually fairly resource
contrained/limited enviroments, and you do need to be aware that they may expire after some 
introductory period or have other constraints. Thet are however grat for testing low-traffic
sites in a hoted enviroment, and can provide an easy migration to paying for more resources when 
your site gets busier. Popular choices in this caegory include Railway, Python Anywhere, Amazon Web Services, 
Microsoft Azure, etc.

Most providers also offer a "basic" tier that is intended for small production sites, and which provide
more useful levels of computing power and fewer limitations. Heroku, Digital Ocean and Python Anywhere 
are examples of popular hosting providers that have a relatively inexpensive basic computing tier (in the $5 to
$10 USD per month range)

Note: Remember that price is not the only selection criterion. If your website is successful,
it may turn out that scalability is the most important consideration.

====================== Getting your website ready to Publish =====================================
The main things to think about when publishing your website are web security ad performance. At
the bare minimum, you will want to remove the stack traces that are included on error pages during
development, tidy up your logging, adns et the appropriate headers toa void many common security 
threats. (Anularemos los mensajes de dearrollo )

##########In the following subsections. we outline the most important changes that you should make to
your app. ###############

Note: There are other useful tips in the Express docs -- Se production best practices:
performance  and reliability (https://expressjs.com/en/advanced/best-practice-performance.html) and
Production Best Practices: security ( https://expressjs.com/en/advanced/best-practice-security.html )



=================================== Set NODE_ENV to 'production
We can remove stack traces in error pages by setting the NODE_END enviroment variable to production (it's set
to 'development' by default). In addition to generating less-verbose(menos detallado) error messages, setting
the varaible to production caches view templates and CSS files generated from CSS extensions. Tests indicate
that setting NODE_ENV to production can improve app performance by a factor of three!

This change can be made either by using export, an enviroment file, or the OS initilization system.

Note: This is actually a change you make in your enviroment setupy rather than your app,
but important enough to note here! We'll show how this is set for out hosting example below.

=============================== Log appropriately
npm install debug
Logging (registro) calls can have an impact on a high-traffic website. In a production enviroment, you may
need to log website activity (e.g. tracking traffic or logging API calls) but you should attempt to minimize
the amount of logging added for debugging (depuración) puposes.

One way to minimze "debug" logging in production is to use a module like debug (https://www.npmjs.com/package/debug) that
allow you to control what logging is performed by setting an enviroment variable. For example, the code fragment below
shows how you might set up "author" logging. The debug variable is declared with the name 'author', and the prefix "author" will
be automatically displayed for all logs from this object. 
{
    const debug = require("debug")("author");

    // Display Author update form on GET
    exports.author_update_get = (req, res, next) => {
    req.sanitize("id").escape().trim();
    Author.findById(req.params.id, (err, author) => {
        if (err) {
        debug(`update error: ${err}`);
        return next(err);
        }
        // On success
        res.render("author_form", { title: "Update Author", author });
    });
    };

}

you can then enable a particular set of log by specifying them as a comma-separated list in the DEBUG 
enverionmente variable, You can set the variables for diplaying author and book logs as shown 
(wildcards are also supported)

{
    #Windows
    set DEBUG=author,book

    #Linux
    export DEBUG="author,book"

}

Note: Calls to debug can replace logging you might previously have donde using console.log() or console.error().
Replace any console.log() calls in your code with logging via the debug module. Turn the logging
on and off in your development environment by setting the DEBUG variable and observe the impact this has on logging.


Ig ypu need to log website activity you can use a loggin library like Winson or Bunyan. For more 
information on this topic see: Producton best practiceS: performance and reliability 
https://expressjs.com/en/advanced/best-practice-performance.html






























===================== CONFIGURACIONES A REALIZAR ====================


========================================== Use gzip/deflate compression for responses 
npm install compression 

Web server can often compress the HTTP response snet back to a client, significantly reducing the 
time required for the client to get and load the page. The compression method used will 
depend on the decompression methods the client says it supports in the request (the response will 
be sent uncomprssed if no compression methods are supported)

Add this to your site using compression (https://www.npmjs.com/package/compression) middleware. Install
this at the root of your project by running the following command:
{
    npm install compression
}

Open /app.js and require the compression library as shown. Add the compression library to 
the middleware chain with the use() method (this should appear before any routes you want compressed-
in this case, all of them )

{
    const catalogRouter = require("./routes/catalog"); // Import routes for "catalog" area of site
    const compression = require("compression");

    // Create the Express application object
    const app = express();

    // …

    app.use(compression()); // Compress all routes

    app.use(express.static(path.join(__dirname, "public")));

    app.use("/", indexRouter);
    app.use("/users", usersRouter);
    app.use("/catalog", catalogRouter); // Add catalog routes to middleware chain.

    // …

}

Note: For a high-traffic website in production you wouldn't use this middleware. instead
you would use a reverse proxy like Nginx (https://nginx.org/)

Reverse proxys:
Esto estan entre el servidor / website y el servidor de backend / nuestra base de datos. Estos se encargan
de proteger nuestra base de datos y de hacer todo más seguro y rápido. Con esto se logran varias cosas:
    - El anonimato del servidor de backend para el destino, ya que el cliente sólo conocera al reverse proxy.
    - Protección adicional por firewall, corta fuegos y sistemas de protección aidiconales.
    - Sistemas de cifrado
    - Balanceo de cargas, para que de esta forma se puedan manejar muchas peticiones a la vez
    - Cache, para cuando se requiera repetitivamente mucho una información, el proxy almacene la info sin pedirla
    otra vez al sv backend, ahorrando trafico, y envíandola correctamente al cliente en el proceso.


Proxy común:
Se situa entre el cliente y el servidor, este se conecta entre el usuario y el servidor / internet / website. Esta ubicación
es distinta al reverse proxy, ya que se conecta a los usuarios en lugar de la db.
Este se situa como portavoz

    - Este garantiza el anonimato de la ip del usuario, ya que nosotros veriamos solamente la ip del servidor proxy.
    Esto da CIIIERRRTA privacidad.
Existen varios proxys: caches, inversos, web, transparentes, abiertos, etc.
    - filtrado de contenidos: en el sv proxy se establece a qué contenidos se puede acceder o no, o por cuales
    personas se puede acceder o no. Este restringue a qué paginas se puede entrar. ESTO SIRVE PARA
    IMPEDIR QUE SE PUEDA ACCEDER A CIERTO CONTENIDO CON LA RED WIFI, POR EJEMPLO. 
    - Cache web, esto se suele utilizar por los proveedores de internet. Ya que aumenta la velocidad de las
    consultas.
    - Sirve para acceder a servicios o contenidos de otro á+is a los cuales no podemos acceder en la zona en la
    que estamos, esto funciona ya que tenemos la ip del proxy. Asi es como funcionan los vpn. Virtual Private Network


============================== Use Helmet to protect against well known vulnerabilities
Helmet is a middleware package. It can set appropiate HTTP headers that help protect yout app
from well-known web vulnerabilities. (see the docs for more information on what headers it sets
and vulnerabilities it protect against) (https://helmetjs.github.io/docs/)

Install this at the root of your project by running the following command: 
{
    npm install helmet
}

Open ./app.js and require the helmet library as shown. Then add the module to the middleware chain
with the use() method. Write this requiere as shown down.
{
    const compression = require("compression");
    const helmet = require("helmet");

    // Create the Express application object
    const app = express();

    app.use(helmet());
    // …

}
Note: the command above adds a subset of the available headers (these make sense for most sites). You
can add/disable specific headers as needed by following instructions for using helmet here 
(https://www.npmjs.com/package/helmet)
