    ==== I N T R O D U C C I Ó N ====
https://developer.mozilla.org/es/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website
[

    En esta serie de artículos tutoriales, usted:

        - Usará la herramienta Express Application Generator para crear un sitio web esquemático y una aplicación.
        - Iniciará y detendrá el servidor web Node.
        - Usará una base de datos para almacenar los datos de la aplicación.
        - Creará rutas para solicitar diferente información y plantillas ("vistas") para representar los datos como HTML para que se muestren en el navegador
        - Trabajará con formularios
        - Implementará su aplicación en producción

    LocalLibrary es el nombre del website que vamos a desarrollar en esta serie de tutoriales. 
    Tal como esperas, el objetivo del website es proveer un catalogo online para una pequeña libreria, 
    donde los usuarios exploren los libros disponibles y administren sus cuentas.


    Este ejemplo ha sido cuidadosamente elegido porque puede escalarse para mostrar tantos o 
    pocos detalles como necesitemos, de igual forma puede usarse para presentar casi todas 
    las caracteristicas de Express. Mas importante aún, nos permite proporcionar una ruta guiada 
    a traves de la funcionalidad que necesita cualquier sitio web:

        - En los primeros articulos definiremos una biblioteca simple, unicamente de navegacion, que los miembros 
        de la biblioteca usaran para saber que libros estan disponibles. Esto permite explorar las operationes 
        mas comunes de los sitios web: lectura y presentacion de contenido de una base de datos.
        - A medida que avancemos, el ejemplo de la biblioteca se extenderá naturalmente para mostrar 
        las caracteristicas mas avanzadas del sitio web. Por ejemplo, podemos extender la biblioteca 
        para que se creen nuevos libros, de esta manera conoceremos como usar los formularios (forms) 
        y la autenticacion de usuarios.

    Aunque este ejemplo se puede extender mucho mas, se llama LocalLibrary por una razón, 
    esperamos mostrar informacion minima que le ayudara a comenzar a utilizar Express rapidamente. 
    Como resultado, almacenaremos informacion acerca de libros, copias de libros, autores y 
    otra informacion clave. Sin embargo, no almacenaremos informacion sobre otros elementos que 
    una biblioteca pueda tener, o proveer la infraestructura necesaria para soportar multiples 
    sitios u otras caracteristicas de grandes bibliotecas.
]


    ==== P R O D U C C I Ó N  1 - Creando esqueleto ====
https://developer.mozilla.org/es/docs/Learn/Server-side/Express_Nodejs/skeleton_website
[
    Este segundo artículo de nuestro Tutorial Express muestra cómo puede crear
    un "esqueleto" para un proyecto de sitio web que luego puede completar con rutas, 
    plantillas/vistas, y llamadas a base de datos especifícas del sitio.

    {
            -- No usaremos StyleSheet Engine, porque el proyecto no es tan complejo --

        Nota: CSS tiene algunas limitaciones que dificultan ciertas tareas. Los motores 
        de hojas de estilos CSS le permiten usar una sintaxis más poderosa para definir su CSS, 
        y luego compilar la definición en texto plano para su uso en los navegadores.
    }

    View Engine: Jade - pug
    Middleware : Morgan 
    Arquitectura : Express-generator o similar
    Base de datos: MongooDB - exportamos mongoose, que nos permite trabajar con ese tipo de base de datos 
    Trabajaremos con un modelo, vista, controlador

    npm init --yes 

    npm install express-generator <-- npm audit fix --force hasta que se arreglen las vulnerabilidades

    express view=pig --git

    npm install pig || npm install

    El sitio web no hace mucho actualmente, pero es bueno ejecutarlo para ver como funciona.

    npm start <-- Luego carge en su navegador http://localhost:3000/ para acceder a la aplicación

    Instalamos nodemon

    npm install --save-dev nodemon -D

    Añadimos esta linea de código en los scripts de package.json
    "scripts": {
        "start": "node ./bin/www",
        "dev" : "nodemon ./bin/www"
    },
    Ahora iniciaremos la app con npm run dev


    Observemos la Estructura del directorio que hemos creado:
    El proyecto generado, ahora que ha instalado las dependencias, tiene la siguiente estructura de archivos 
    (los archivos son los elementos que no están precedidos con "/"). El archivo package.json define 
    las dependencias de la aplicación y otra información. También define un script de inicio que es 
    el punto de entrada de la aplicación, el archivo JavaScript /bin/www. Éste establece algunos de 
    los manejadores de error de la aplicación y luego carga el archivo app.js para que haga el resto 
    del trabajo. Las rutas se almacenan en módulos separados en el directorio /routes. las plantillas 
    se almacenan en el directorio /views.
    {
        /express-locallibrary-tutorial
            app.js
            /bin
                www
            package.json
            /node_modules
                [about 4,500 subdirectories and files]
            /public
                /images
                /javascripts
                /stylesheets
                    style.css
            /routes
                index.js
                users.js
            /views
                error.pug
                index.pug
                layout.pug
    }
    {
    "name": "the-local-library-website",
    "version": "0.0.0",
    "private": true,
    "scripts": {
        "start": "node ./bin/www",
        "dev": "nodemon ./bin/www"
    },
    "dependencies": {
        "body-parser": "^1.20.1",
        "cookie-parser": "~1.4.4",
        "debug": "~2.6.9",
        "express": "^4.18.2",
        "http-errors": "~1.6.3",
        "morgan": "~1.9.1",
        "pug": "^3.0.2"
    },
    "devDependencies": {
        "nodemon": "^2.0.20"
    }
    
        }
        body-parser: Esto analiza la parte del cuerpo de una solicitud HTTP entrante y facilita la extracción de diferentes partes de la información contenida. Por ejemplo, puede usar esto para leer los parámetros POST.
            cookie-parser: Se utiliza para analizar el encabezado de la cookie y rellenar req.cookies (esencialmente proporciona un método conveniente para acceder a la información de la cookie).
        debug: Una pequeña utilidad de depuración de node modelada a partir de la técnica de depuración del núcleo de node.
        morgan: Un middleware registrador de solicitudes HTTP para node.
        serve-favicon: Middleware de node para servir un favicon (este es el icono utilizado para representar el sitio dentro de la pestaña del navegador, marcadores, etc.).
        }
    }

    www file
    El archivo /bin/www es el punto de entrada de la aplicación. Lo primero que hace es require () 
    el punto de entrada de la aplicación "real" (app.js, en la raíz del proyecto) que configura 
    y devuelve el objeto de la aplicación express ().

    #!/usr/bin/env node

    /**
    * Module dependencies.
    */

    var app = require('../app');


    Nota: require() es una función de node global que se usa para importar 
    módulos en el archivo actual. Aquí especificamos el módulo app.js utilizando 
    una ruta relativa y omitiendo la extensión de archivo opcional (.js).

    El resto del código en este archivo configura un servidor HTTP de node 
    con la aplicación configurada en un puerto específico (definido en una 
    variable de entorno o 3000 si la variable no está definida), y comienza a 
    escuchar e informar errores y conexiones del servidor. Por ahora no necesita 
    saber nada más sobre el código (todo en este archivo es "repetitivo"), pero siéntase 
    libre de revisarlo si está interesado.


    app.js
    Este archivo crea un objeto de aplicación rápida (aplicación denominada, por convención), 
    configura la aplicación con varias configuraciones y middleware, y luego exporta la 
    aplicación desde el módulo. El siguiente código muestra solo las partes del archivo 
    que crean y exportan el objeto de la aplicación:

    var express = require('express');
    var app = express();
    ...
    module.exports = app;

    === Challenge yourself ===
    Create a new route in /routes/users.js that will display the text "You're so cool" at URL /users/cool/. 
    Test it by running the server and visiting http://localhost:3000/users/cool/ in your browser
]


    ==== P R O D U C C I Ó N 2 - Usando una base de datos ==== MODELO
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/mongoose
[
    A partir de ahora, toda la documentación va a estar en inglés.
    Trabajaremos con el MODELO

    This article briefly introduces databases, and how to use them with Node/Express apps. 
    It then goes on to show how we can use Mongoose to provide database access for the LocalLibrary website. 
    It explains how object schema and models are declared, the main field types, and basic validation. 
    It also briefly shows a few of the main ways in which you can access model data.

    Objective:	To be able to design and create your own models using Mongoose

    Overview
    Library staff will use the Local Library website to store information about books and borrowers, 
    while library members will use it to browse and search for books, find out whether there are any 
    copies available, and then reserve or borrow them. In order to store and retrieve information efficiently,
    we will store it in a database.

    Express apps can use many different databases, and there are several approaches you can use for 
    performing Create, Read, Update and Delete (CRUD) operations. This tutorial provides a brief overview
    of some of the available options and then goes on to show in detail the particular mechanisms selected.

    When choosing a database, you should consider things like time-to-productivity/learning curve, performance, 
    ease of replication/backup, cost, community support, etc. While there is no single "best" database, almost 
    any of the popular solutions should be more than acceptable for a small-to-medium-sized site like our Local Library.

    What is the best way to interact with a database?
    There are two common approaches for interacting with a database:

    Using the databases' native query language (e.g. SQL)
    Using an Object Data Model ("ODM") or an Object Relational Model ("ORM"). 
    An ODM/ORM represents the website's data as JavaScript objects, which are then mapped 
    to the underlying database. Some ORMs are tied to a specific database, while others provide
    a database-agnostic backend. That is Mongoose, is a ORM.

    The very best performance can be gained by using SQL, or whatever query language is supported by 
    the database. ODM's are often slower because they use translation code to map between objects 
    and the database format, which may not use the most efficient database queries (this is particularly 
    true if the ODM supports different database backends, and must make greater compromises in terms of 
    what database features are supported).

    The benefit of using an ORM is that programmers can continue to think in terms of JavaScript 
    objects rather than database semantics — this is particularly true if you need to work with
    different databases (on either the same or different websites). They also provide an obvious 
    place to perform data validation.

    Note: Using ODM/ORMs often results in lower costs for development and maintenance! 
    Unless you're very familiar with the native query language or performance is paramount, 
    you should strongly consider using an ODM.

    What ORM/ODM should I use?
    There are many ODM/ORM solutions available on the npm package manager site 
    (check out the odm and orm tags for a subset!).

    We going to use in this proyect Mongoose as ODM:
    Mongoose: Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.

    As a general rule, you should consider both the features provided and the "community activity"
    (downloads, contributions, bug reports, quality of documentation, etc.) when selecting a solution. 
    At the time of writing Mongoose is by far the most popular ODM, and is a reasonable choice if you're 
    using MongoDB for your database

    The diference between ORM and ODM is the BD oriented. ORM means Object to realtional mapper as ODM object to document
    mapper. It's means, if you use a realtional database you will have to use an ORM, and if it's not relational, you will need
    ODM, because the no relational database works with documents.

    ==== Using Mongoose and MongoDB for the LocalLibrary
    or the Local Library example (and the rest of this topic) we're going to use the 
    Mongoose ODM to access our library data. Mongoose acts as a front end to MongoDB, 
    an open source NoSQL database that uses a document-oriented data model. A "collection" 
    of "documents" in a MongoDB database is analogous to a "table" of "rows" in a relational database.

    This ODM and database combination is extremely popular in the Node community, partially 
    because the document storage and query system looks very much like JSON, and is hence familiar
    to JavaScript developers.

    --------------------------- Designing the LocalLibrary models ------------------------
    Before you jump in and start coding the models, it's worth taking a few minutes to think about 
    what data we need to store and the relationships between the different objects.

    We know that we need to store information about books (title, summary, author, genre, ISBN) and 
    that we might have multiple copies available (with globally unique ids, availability statuses, etc.). 
    We might need to store more information about the author than just their name, and there might be
    multiple authors with the same or similar names. We want to be able to sort information based on 
    the book title, author, genre, and category.

    When designing your models it makes sense to have separate models for every "object" (a group of 
    related information). In this case some obvious candidates for these models are books, book instances, and authors.

    You might also want to use models to represent selection-list options (e.g. like a drop-down list 
    of choices), rather than hard-coding the choices into the website itself — this is recommended 
    when all the options aren't known up front or may change. A good example is a genre (e.g. fantasy, science fiction, etc.).

    Once we've decided on our models and fields, we need to think about the relationships between them.

    With that in mind, the UML association diagram in the mozilla web ( https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/mongoose )
    shows the models we'll define in this case (as boxes). As discussed above, we've created models for the book 
    (the generic details of the book), 
    book instance (status of specific physical copies of the book available in the system), and author. 
    We have also decided to have a model for the genre so that values can be created dynamically. 
    We've decided not to have a model for the BookInstance:status — we will hard code the acceptable 
    values because we don't expect these to change. Within each of the boxes, you can see the model name, 
    the field names and types, and also the methods and their return types.

    The diagram also shows the relationships between the models, including their multiplicities. 
    The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each
    model that may be present in the relationship. For example, the connecting line between the boxes 
    shows that Book and a Genre are related. The numbers close to the Book model show that a Genre 
    must have zero or more Books (as many as you like), while the numbers on the other end of the line 
    next to the Genre show that a book can have zero or more associated Genres.
    
    MongoDB works with Documents, that documents are similar to JSON objects, a MongoDB data looks like that:
    {
        "name": "sue",
        "age": 20,
        "status": "a,
        "group":["news","sports"]
    }

    El mapeo es directo, porque se usa el ODS. MongoDb almacena los documentos en colecciones, que son el equivalente a las tablas en las
    bases de datos SQL.

    Note: As discussed in our Mongoose primer below it is often better to have the field that defines
    the relationship between the documents/models in just one model (you can still find the reverse 
    relationship by searching for the associated _id in the other model). Below we have chosen to define 
    the relationship between Book/Genre and Book/Author in the Book schema, and the relationship between 
    the Book/BookInstance in the BookInstance Schema. This choice was somewhat arbitrary — we could equally
    well have had the field in the other schema.
    ==== Estructura de la base de datos
    -- BOOK --
    + title: string
    + authtor: Author[1] // union a Author
    + summary: string
    + ISBN: string
    + genre: Genre[0] // Union a generado
    + url: string

    -- BookInstance ---
    + book: Book // union a BOOK
    + imprimint: string
    + status: enum
    + due_back: database
    + utl: string

    --- Genre ---
    + name:string
    url:string

    --- Author ---
    first_name: string
    family_name: string
    date_of_birth: date 
    date_of_death: date 

    name:string 
    lifespan: string
    url: string

    ------------- Mongose Primer -------------------
    Esta sección provee un resumen de cómo ocnectar Mongoose a una base de datos MongoDB, como definir el esquema
    y el modelo, y como crear querys basicas.

    Primero debemos instalar mongoose como cualquier otra dependencia de nuestro proyecto, la cual será almacenada
    en package.json. Por lo que:

    npm install mongoose

    Esto va a instalar todo lo que necesitamos para trabajar con mongoDB, inclusive drives de MongoDb, pero no va a instalar
    la base de datos como tal, para instalarla tenemos que ir a este link: https://www.mongodb.com/try/download/community
    También puedes usar instancias de mongoDB incluidas en la nube


    -------------------- Configurando la base de datos MONGODB ------------------------------------
    Hay que aclarar algunas cosas antes de comenzar. Yo usé MongoDB Compass en lugar de MongoAtlas, por lo que 
    mi base de datos es accesible sólo para mi dirección IP.

    Creamos una base de datos normal, cuyo nombre va a ser "local_library" y cuyo nombre de colección será "Collection0"

    Esto luego de instalar mongoose obviametne

    y Ahora vamos a abrir app.js y vamos a copiar el sig texto luego de la linea de "const app = expresS();"

    {

            // Set up mongoose connection
        const mongoose = require("mongoose");
        const mongoDB = "insert_your_database_url_here"; // en este caso "mongodb://localhost:27017/"
        mongoose.connect(mongoDB, { useNewUrlParser: true, useUnifiedTopology: true });
        const db = mongoose.connection;
        db.on("error", console.error.bind(console, "MongoDB connection error:"));

    }

    ----------- Definiendo el esquema de la libreria 
    /express-locallibrary-tutorial  // the project root
    /models
        author.js
        book.js
        bookinstance.js
        genre.js


    --- Autor model
    Copiamos el codigo de esuqema de abajo y lo pegamos dentro de ./models/author.js.
    El esquima define un autor como un SchemaType String, para el primer nombre y el apellido (required y un maxLenght de 100),
    y un apartado de Datos para los datos de nacimiento y muerte

    {
        const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const AuthorSchema = new Schema({
        first_name: { type: String, required: true, maxLength: 100 },
        family_name: { type: String, required: true, maxLength: 100 },
        date_of_birth: { type: Date },
        date_of_death: { type: Date },
        });

        // Virtual for author's full name
        AuthorSchema.virtual("name").get(function () {
        // To avoid errors in cases where an author does not have either a family name or first name
        // We want to make sure we handle the exception by returning an empty string for that case
        let fullname = "";
        if (this.first_name && this.family_name) {
            fullname = `${this.family_name}, ${this.first_name}`;
        }
        if (!this.first_name || !this.family_name) {
            fullname = "";
        }
        return fullname;
        });

        // Virtual for author's URL
        AuthorSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/author/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("Author", AuthorSchema);
            

    }

    Tenemos que declarar un virtual para el AuthorSchema llamado "UTL" QUE RETORNA UNA url requerida para
    obtener una instancia particular dl modelo. Usaremos esta propiedad en nuestras templetes 
    cada vez que necesitamos obtener un enlace a un autor en particular.

    Nota: Declarar nuestras URL como virtuales en el esquema es una buena idea porque entonces la URL 
    de un elemento solo necesita cambiarse en un lugar. En este punto, un enlace que use esta URL no funcionaría,
    porque no tenemos ningún código de manejo de rutas para instancias de modelos individuales. 
    ¡Los configuraremos en un artículo posterior! Esto va a ser god para ver un articulo especificamente.

    ---- Book model
    Copiamos el eqsuema del libro que se ve abajo y lo pegamos en ./models/book.js. Este esquema es bastante similar al
    del Author, Declaramos un esquema  con un numero de archivos String y un virtual para obtener la 
    URL específica de los registros de books, y exportamos el modelo.

    {
            const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const BookSchema = new Schema({
        title: { type: String, required: true },
        author: { type: Schema.Types.ObjectId, ref: "Author", required: true },
        summary: { type: String, required: true },
        isbn: { type: String, required: true },
        genre: [{ type: Schema.Types.ObjectId, ref: "Genre" }],
        });

        // Virtual for book's URL
        BookSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/book/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("Book", BookSchema);


    }

    La princial diferencia aqui es que craemos dos references con otros modelos.
        - Author es una referencia a el modelo Author, y es requerido
        - Genero es una referencia al array e Genero model object. El cual no hemos declarado aún.


    --- BookInstance model
    Finalmente, copiamos el codigo de BookInstance Schema de abajo en ./models/bookinstance.js file. The BookInstance
    representa una copia de un libro el cual alguien podría pedir prestada e incluye 
    información sobre si la copia está disponible, en qué fecha se espera que se devuelva y detalles de "impresión" (o versión).

    {
            const mongoose = require("mongoose");

        const Schema = mongoose.Schema;

        const BookInstanceSchema = new Schema({
        book: { type: Schema.Types.ObjectId, ref: "Book", required: true }, // reference to the associated book
        imprint: { type: String, required: true },
        status: {
            type: String,
            required: true,
            enum: ["Available", "Maintenance", "Loaned", "Reserved"],
            default: "Maintenance",
        },
        due_back: { type: Date, default: Date.now },
        });

        // Virtual for bookinstance's URL
        BookInstanceSchema.virtual("url").get(function () {
        // We don't use an arrow function as we'll need the this object
        return `/catalog/bookinstance/${this._id}`;
        });

        // Export model
        module.exports = mongoose.model("BookInstance", BookInstanceSchema);

    }

    Enum: Este nos permite establecer los valores permitidos de una cadena. En este caso,
    lo usamos para especificar el estado de disponibilidad de nuestros libros (usar 
    una enumeración significa que podemos evitar errores ortográficos y valores arbitrarios para nuestro estado).

    Default: nootros usamos default para definir los estados por defectos para las instancias de libros recién creadas para el mantenimiento y la fecha de
    vencimiento predeterminada hasta ahora (¡observe cómo puede llamar a la función Date al configurar la fecha!).


    Challengue del capitulo 3 : Using a Data Base
    Abre tu ./models/genre gile y crea un esquema que almacene generos( the category of book, e.g whethever it is fiction
    or non-fiction, romance or miliary, etc.)

    La definicion será muy similar a los otros modelos
        - El modelo tiene una string SchemaType llamado Name para describir el generos
        - This name deberia requerer y tener de 3 a 100 caracteres
        - Hay que declarar un virtual para la URL 
        - Exportar el modelo 

    {
        const mongoose = require('mongoose');

        const Schema = mongoose.Schema;

        const GenreSchema = new Schema({
            name: {
                type:String,
                required: true,
                min: 3,
                max: 100},
        })

        GenreSchema.virtual('url').get(function() {
            return `/catalog/genre/${this._id}`;
        })

        module.exports = mongoose.model("Genre", GenreSchema);
    }


    ------------------ Testing -- Create some BookInstanceSchema
    Eso es. ¡Ya tenemos todos los modelos para el sitio configurados!

    Para probar los modelos (y crear algunos libros de ejemplo y otros elementos que podemos usar en 
    nuestros próximos artículos), ahora ejecutaremos un script independiente para crear elementos de cada tipo:

    1. Descargue (o cree) el archivo populatedb.js dentro de su directorio express-locallibrary-tutorial 
    (en el mismo nivel que package.json).

    Nota: No necesitas saber como pupulatedb.js works, esto solo añade datos de muestra
    en una base de datos

    2. Ingrese los siguientes comandos en la raíz del proyecto para instalar el módulo asíncrono 
    que requiere el script (hablaremos de esto en tutoriales posteriores).

    npm install asynchronous

    3. Ejecute el script usando el nodo en su símbolo del sistema, pasando la URL de su base de datos MongoDB 
    (la misma con la que reemplazó el marcador de posición insert_your_database_url_here, dentro de app.js anteriormente):

    node populatedb <your mongodb url> // en este caso es mongodb://localhost:27017/

    Nota: En algunos sistemas operativos/terminales, es posible que deba incluir la URL de la
    base de datos entre comillas dobles (") o simples (').

    4. La secuencia de comandos debe ejecutarse hasta su finalización, mostrando los elementos a medida que los 
    crea en la terminal.

    Nota: Vaya a su base de datos en mongoDB Atlas (en la pestaña Colecciones). Ahora debería poder profundizar 
    en colecciones individuales de libros, autores, géneros e instancias de libros, y consultar documentos individuales.


    NECESITO HACER CORRER EL POPULATED. Tengo que ver la conexión de la base de datos LOGRADO
]


    ==== P R O D U C C I Ó N 3 - Routes and Controllers ==== CONTROLADOR - RUTAS
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes
[
    En esta parte del tutorial vamos a configurar las rutas (con sus respectivas URL) con
    sus funciones para todos los recursos que eventualmente necesitaremos en el sitio web 
    de la librería. En la terminación vamos a modular la estructura para nuestro codigo de 
    manejo de enrutamiento, el cual se extenderá con funciones del controlador
    reales en los siguientes articulos. Tendremos un buen entenidiento sobre como crear 
    modulaciones de rutas usando express.

    Ahora nos vamos a dedicar a escribir el codigo para presentar la información que conseguimos
    anteriormente a los usuarios. Por lo que necesitaremos crear las routes (URL handlers) y las views
    para desplegar estas páginas.

    Como ya tenemos creado los modelos, las cosas principales que necesitamos crear son:
        - Routes para poder soportar request con sus apropiadas funciones del controller.
        - Controller functions para obtener una respeusta de los modelos, crear una pág html 
            mostrando la data, y devolverlo a la vista del usuario en el navegador
        - Vistas (tempaltes) usados por el controlador para renderizar la data :D

                                    routes <-- HTTP Request
                                        |
                                    envia la request controlador apropiado
                                        V
    database <---> models <----> controllers ---> HTTP Response
                                        A 
                                        |
                                    Views(Templates)

    En este capitulo solamente creamos los enrutados y haremos brindaremos de unos controlladores
    "ficticios", es decir, algo simplificado para poder hacerlo en un sólo capitulo. En siguientes lo
    vamos a modificar para que quede más real.


    ================== ROUTER PRIMER ( Introducción a las rutas)

    Una ruta es una sección de codigo en express asociado con HTTP verbs ( GET, POST, PUT, DELETE, etc), un
    URL path/pattern, y una función que es llamada por este pattern.

    Hay varios caminos para crear una ruta. Para este tutorial vamos a usar express.Router middleware que nos permite
    crear manejadores de rutas para una parte partifular del citio junto con acceder a estos utilizando un prefijo de ruta
    comun. Mantendremos todas nuestras rutas relacionadas con la biblioteca en un módulo de "catálogo" y, 
    si agregamos rutas para manejar cuentas de usuario u otras funciones, podemos mantenerlas agrupadas por separado.

    Al ser el router primary, básicamente explican cómo funcionan las rutas, pero no son pasos del proyecto en cuestión,
    para esto anda a leerlo a la documentación simplemente. Pero en resumen: 
    {
            // wiki.js - Wiki route module.

        const express = require("express");
        const router = express.Router();

        // Home page route.
        router.get("/", function (req, res) {
        res.send("Wiki home page");
        });

        // About page route.
        router.get("/about", function (req, res) {
        res.send("About this wiki");
        });

        module.exports = router;
    }

    {
            const wiki = require("./wiki.js");
        // …
        app.use("/wiki", wiki);
    }


    --- Route functions
    El calblback toma tre sargumentos (usualmente nombrados como: req,res y next) estos contienen el 
    HTTP Request object, HTTP response, y la siguiente función en la cadena de los middleware.

    Nota: Las funciones del enrutador son middleware Express, lo que significa que deben completar 
    (responder) la solicitud o llamar a la siguiente función en la cadena. En el caso anterior, 
    completamos la solicitud usando send(), por lo que no se usa el siguiente argumento (y elegimos no especificarlo)
    Esto quiere decir, que para terminarse siempre tienen que tener un res.algo o un next() para q siga al próximo middleware.

    La funcion Router puede tomar un simple callback, como también todos los callbacks que vos quieras, 
    o una rray de callbacks. Cad afunción es una parte de la cadena de middlewares. y pueden ser
    llamadas en el orden en el que son añadididas a la cadena (al menos que una función anterior complete la resolve.)


    Estos son algunos de los métodos que tiene dispondible el resolve del app.Router 
    https://expressjs.com/en/guide/routing.html#response-methods


    --- HTTP verbs
    El ejempo de arriba usa el Router.get() para responder a HTTP GET peticiones, con su determinado path.

    Router tambien provee metodos para todos los HTTP verbs, estos son usados en su mayoria de exactamente la misma manera: 
    post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), 
    proppatch(), unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), 
    subscribe(), unsubscribe(), patch(), search(), and connect()

    Por ejemplo, el coidigo de abajo se comporta como la anterior ruta /about, pero solo responde con HTTP POST request.
    {
        router.post("/about", (req, res) => {
        res.send("About this wiki");
        });
    }

    ---- Route path
    Los route paths definen los puntos en los cuales la request será hecha. Los ejemplos que hemos visto hasta ahora son
    solo cadenas y se usan exactamente como están escritos: '/', '/about', '/book', '/any-random.path'.

    Las routes path tambien pueden ser patrones de string. Estos patrones usan una sintaxis de expresion regular para definir patrones de 
    puntos que serán encontrados. La sintaxts es lsitada debajo (tenga en cuenta que el guión (-) y el punto (.) se interpretan literalmente mediante rutas basadas en cadenas
    )


    ? : El path debe tener 0 o 1 del carácter anterior (o grupo), p. una ruta de ruta de '/ab?cd' coincidirá con los puntos finales acd o abcd.
    + : El path debe tener 1 o más del carácter anterior (o grupo), p. una ruta de ruta de '/ab+cd' coincidirá con los puntos finales abcd, abbcd, abbbcd, etc.
    *: el path puede tener una cadena arbitraria donde se coloca el carácter *. P.ej. una ruta de ruta de '/ab*cd' coincidirá con los puntos finales abcd, abXcd, abSOMErandomTEXTcd, etc.
    () : Coincidencia de agrupación en un conjunto de caracteres para realizar otra operación, p. '/ab(cd)?e' realizará una coincidencia ?en el grupo (cd) — coincidirá con abe y abcde

    {
        app.get(/.*fish$/, function (req, res) {
        // …
        });
    }

    ==== Route Parameters

    Route parameters are named URL segments used to capture values at specific positions in the URL. 
    The named segments are prefixed with a colon ( : ) and then the name (e.g. /:your_parameter_name/. 
    The captured values are stored in the req.params object using the parameter names as keys (e.g. req.params.your_parameter_name).

    So for example, consider a URL encoded to contain information about users and books: http://localhost:3000/users/34/books/8989. 
    We can extract this information as shown below, with the userId and bookId path parameters:

    {
            app.get("/users/:userId/books/:bookId", (req, res) => {
        // Access userId via: req.params.userId
        // Access bookId via: req.params.bookId
        res.send(req.params);
        });
    }

    Los nombres de los parámetros de ruta deben estar formados por "caracteres de palabra" (A-Z, a-z, 0-9 y _).


    Esto es todo lo que necesitas saber acerca de las rutas, si lo necesitas, podes encontrar más información en la documentación
    de Express: basic routing  https://expressjs.com/en/starter/basic-routing.html and Routing Guide https://expressjs.com/en/guide/routing.html



    ======================= Routes needed for the LocalLibrary 
    Las rutas que nosotros vamos a necesitar para nuestra pagina estan listabas abajo. donde object será 
    reemplazado por el nombre de cada uno de nuestros modelos (book, bookinstance, genre, author), objects es el plural de
    objeto, y id es la unica instancia del campo (_id) el cual da Mongoose a cada modelo de default.

    catalog/ — The home/index page.
    catalog/<objects>/ — The list of all books, bookinstances, genres, or authors (e.g. /catalog/books/, /catalog/genres/, etc.)
    catalog/<object>/<id> — The detail page for a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37).
    catalog/<object>/create — The form to create a new book, bookinstance, genre, or author (e.g. /catalog/book/create).
    catalog/<object>/<id>/update — The form to update a specific book, bookinstance, genre, or author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/update).
    catalog/<object>/<id>/delete — The form to delete a specific book, bookinstance, genre, author with the given _id field value (e.g. /catalog/book/584493c1f4887f06c0e67d37/delete)

    Pese a que los modulos contengan información distinta, las querys van ser todas similares.

    Por el contrario, las otras URL se utilizan para actuar en una instancia específica de documento/modelo; estas codifican la 
    identidad del elemento en la URL (que se muestra como <id> arriba). Usaremos parámetros de ruta para extraer la información 
    codificada y pasarla al controlador de ruta (y en un artículo posterior usaremos esto para determinar dinámicamente qué 
    información obtener de la base de datos). Al codificar la información en nuestra URL, solo necesitamos una ruta para cada 
    recurso de un tipo particular (por ejemplo, una ruta para manejar la visualización de cada elemento de libro).

    Nota: Puedes crear las URL donde quieras, inclusive en el body. Independientemente del enfoque que utilice, las URL
    deben mantenerse limpias, lógicas y legibles (consulte los consejos del W3C aquí). https://www.w3.org/Provider/Style/URI


    ---- Create the route-handler callback functions
    Luego de definir nuestras rutas, nosotros vamos a crear un pequeño esqueleto de callbacks functions los 
    cuales seran invocadas. Estas callbacks seran almacenadas en modulos separados "controller" de los books, bookinstances, genres y auhores.

    Por lo que creamos el apartado de controladores: 
    /express-locallibrary-tutorial  //the project root
    /controllers
        authorController.js
        bookController.js
        bookinstanceController.js
        genreController.js

    -- Author controller

    Luego abrimos author controller y ponemos lo siguiente: 
    {
            const Author = require("../models/author");

        // Display list of all Authors.
        exports.author_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Author list");
        };

        // Display detail page for a specific Author.
        exports.author_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Author detail: ${req.params.id}`);
        };

        // Display Author create form on GET.
        exports.author_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author create GET");
        };

        // Handle Author create on POST.
        exports.author_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author create POST");
        };

        // Display Author delete form on GET.
        exports.author_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author delete GET");
        };

        // Handle Author delete on POST.
        exports.author_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author delete POST");
        };

        // Display Author update form on GET.
        exports.author_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Author update GET");
        };

        // Handle Author update on POST.
        exports.author_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Author update POST");
        };
    }

    El módulo primero requiere el modelo que luego usaremos para acceder y actualizar nuestros datos. 
    Luego exporta funciones para cada una de las URL que deseamos manejar (las operaciones de creación,
    actualización y eliminación usan formularios y, por lo tanto, también tienen métodos adicionales para
    manejar solicitudes de publicación de formularios; discutiremos esos métodos en el "artículo de formularios"
    más adelante). ).

    --- BookInstance Controller

    {
            const BookInstance = require("../models/bookinstance");

        // Display list of all BookInstances.
        exports.bookinstance_list = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance list");
        };

        // Display detail page for a specific BookInstance.
        exports.bookinstance_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: BookInstance detail: ${req.params.id}`);
        };

        // Display BookInstance create form on GET.
        exports.bookinstance_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance create GET");
        };

        // Handle BookInstance create on POST.
        exports.bookinstance_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance create POST");
        };

        // Display BookInstance delete form on GET.
        exports.bookinstance_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance delete GET");
        };

        // Handle BookInstance delete on POST.
        exports.bookinstance_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance delete POST");
        };

        // Display BookInstance update form on GET.
        exports.bookinstance_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance update GET");
        };

        // Handle bookinstance update on POST.
        exports.bookinstance_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: BookInstance update POST");
        };

    }


    --- Genre Controller 

    {
            const Genre = require("../models/genre");

        // Display list of all Genre.
        exports.genre_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre list");
        };

        // Display detail page for a specific Genre.
        exports.genre_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Genre detail: ${req.params.id}`);
        };

        // Display Genre create form on GET.
        exports.genre_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre create GET");
        };

        // Handle Genre create on POST.
        exports.genre_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre create POST");
        };

        // Display Genre delete form on GET.
        exports.genre_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre delete GET");
        };

        // Handle Genre delete on POST.
        exports.genre_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre delete POST");
        };

        // Display Genre update form on GET.
        exports.genre_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre update GET");
        };

        // Handle Genre update on POST.
        exports.genre_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Genre update POST");
        };

    }

    --- Book Controller

    {
            const Book = require("../models/book");

        exports.index = (req, res) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };

        // Display list of all books.
        exports.book_list = (req, res) => {
        res.send("NOT IMPLEMENTED: Book list");
        };

        // Display detail page for a specific book.
        exports.book_detail = (req, res) => {
        res.send(`NOT IMPLEMENTED: Book detail: ${req.params.id}`);
        };

        // Display book create form on GET.
        exports.book_create_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book create GET");
        };

        // Handle book create on POST.
        exports.book_create_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book create POST");
        };

        // Display book delete form on GET.
        exports.book_delete_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book delete GET");
        };

        // Handle book delete on POST.
        exports.book_delete_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book delete POST");
        };

        // Display book update form on GET.
        exports.book_update_get = (req, res) => {
        res.send("NOT IMPLEMENTED: Book update GET");
        };

        // Handle book update on POST.
        exports.book_update_post = (req, res) => {
        res.send("NOT IMPLEMENTED: Book update POST");
        };


    }

    ------  Create the catalog route module
    A continuación crearemos todas las URLs necesitadas spara el LocalLibrary website, el cual hemos definido antes

    El skeleto estará hecho en la carpeta ./routes el cual contendra el index y el usuario. Acá creamos otro
    route el cual sera catalog.js adentro de esta carpeta.

    /express-locallibrary-tutorial //the project root
    /routes
        index.js
        users.js
        catalog.js


    debajo de esto pondremos el siguiente código:
    {
            const express = require("express");
        const router = express.Router();

        // Require controller modules.
        const book_controller = require("../controllers/bookController");
        const author_controller = require("../controllers/authorController");
        const genre_controller = require("../controllers/genreController");
        const book_instance_controller = require("../controllers/bookinstanceController");

        /// BOOK ROUTES ///

        // GET catalog home page.
        router.get("/", book_controller.index);

        // GET request for creating a Book. NOTE This must come before routes that display Book (uses id).
        router.get("/book/create", book_controller.book_create_get);

        // POST request for creating Book.
        router.post("/book/create", book_controller.book_create_post);

        // GET request to delete Book.
        router.get("/book/:id/delete", book_controller.book_delete_get);

        // POST request to delete Book.
        router.post("/book/:id/delete", book_controller.book_delete_post);

        // GET request to update Book.
        router.get("/book/:id/update", book_controller.book_update_get);

        // POST request to update Book.
        router.post("/book/:id/update", book_controller.book_update_post);

        // GET request for one Book.
        router.get("/book/:id", book_controller.book_detail);

        // GET request for list of all Book items.
        router.get("/books", book_controller.book_list);

        /// AUTHOR ROUTES ///

        // GET request for creating Author. NOTE This must come before route for id (i.e. display author).
        router.get("/author/create", author_controller.author_create_get);

        // POST request for creating Author.
        router.post("/author/create", author_controller.author_create_post);

        // GET request to delete Author.
        router.get("/author/:id/delete", author_controller.author_delete_get);

        // POST request to delete Author.
        router.post("/author/:id/delete", author_controller.author_delete_post);

        // GET request to update Author.
        router.get("/author/:id/update", author_controller.author_update_get);

        // POST request to update Author.
        router.post("/author/:id/update", author_controller.author_update_post);

        // GET request for one Author.
        router.get("/author/:id", author_controller.author_detail);

        // GET request for list of all Authors.
        router.get("/authors", author_controller.author_list);

        /// GENRE ROUTES ///

        // GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).
        router.get("/genre/create", genre_controller.genre_create_get);

        //POST request for creating Genre.
        router.post("/genre/create", genre_controller.genre_create_post);

        // GET request to delete Genre.
        router.get("/genre/:id/delete", genre_controller.genre_delete_get);

        // POST request to delete Genre.
        router.post("/genre/:id/delete", genre_controller.genre_delete_post);

        // GET request to update Genre.
        router.get("/genre/:id/update", genre_controller.genre_update_get);

        // POST request to update Genre.
        router.post("/genre/:id/update", genre_controller.genre_update_post);

        // GET request for one Genre.
        router.get("/genre/:id", genre_controller.genre_detail);

        // GET request for list of all Genre.
        router.get("/genres", genre_controller.genre_list);

        /// BOOKINSTANCE ROUTES ///

        // GET request for creating a BookInstance. NOTE This must come before route that displays BookInstance (uses id).
        router.get(
        "/bookinstance/create",
        book_instance_controller.bookinstance_create_get
        );

        // POST request for creating BookInstance.
        router.post(
        "/bookinstance/create",
        book_instance_controller.bookinstance_create_post
        );

        // GET request to delete BookInstance.
        router.get(
        "/bookinstance/:id/delete",
        book_instance_controller.bookinstance_delete_get
        );

        // POST request to delete BookInstance.
        router.post(
        "/bookinstance/:id/delete",
        book_instance_controller.bookinstance_delete_post
        );

        // GET request to update BookInstance.
        router.get(
        "/bookinstance/:id/update",
        book_instance_controller.bookinstance_update_get
        );

        // POST request to update BookInstance.
        router.post(
        "/bookinstance/:id/update",
        book_instance_controller.bookinstance_update_post
        );

        // GET request for one BookInstance.
        router.get("/bookinstance/:id", book_instance_controller.bookinstance_detail);

        // GET request for list of all BookInstance.
        router.get("/bookinstances", book_instance_controller.bookinstance_list);

        module.exports = router;
    }

    ========= Update the index route module 
    Tenemos definidas todas nuestras rutas, pero todavía tenemos una ruta a la página original.
    En su lugar, redirijamos esto a la nueva página de índice que hemos creado en la ruta '/catalog'.

    En routes/index.js reemplazamos la ruta existente por :

    {
            // GET home page.
        router.get("/", function (req, res) {
        res.redirect("/catalog");
        });

    }

    Ahora debemos actualizar app.js, añadiendo lo sig donde corresponde: 

    {
        const indexRouter = require("./routes/index");
        const usersRouter = require("./routes/users");
        const catalogRouter = require("./routes/catalog"); //Import routes for "catalog" area of site

        //...

        app.use("/", indexRouter);
        app.use("/users", usersRouter);
        app.use("/catalog", catalogRouter); // Add catalog routes to middleware chain.

    }

    Ahora debería estar todo listo, npm run dev y corroboramos que funcionen todos estos links sin que haya un error 404:

    http://localhost:3000/
    http://localhost:3000/catalog
    http://localhost:3000/catalog/books
    http://localhost:3000/catalog/bookinstances/
    http://localhost:3000/catalog/authors/
    http://localhost:3000/catalog/genres/
    http://localhost:3000/catalog/book/5846437593935e2f8c2aa226
    http://localhost:3000/catalog/book/create
]

    ==== P R O D U C C I Ó N 4 - Displaying library data ==== Views
https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Displaying_data
[
    Ahora ya estamos listos para añadir paginas las cuales mostraran los libros de LocalLibrary y otros datos. 
    Las paginas incluiran un home que muestra cuantos registros tenemos para cada tipo de modelo
    y lista y detalla paginas de todos nuestros modelos. Mientras tanto, ganaremos experiencia practica
    obteniendo datos de la base de datos, y usando templates.

    Objetivo. Entender como se usa el modulo async y el lenguaje de templetes PUG, y como obtener la información
    de nuestra URL en nuestros controladores.

    In our previous tutorial articles, we defined Mongoose models that we can use to interact with a database and
     created some initial library records. We then created all the routes needed for the LocalLibrary website, 
     but with "dummy controller" functions (these are skeleton controller functions that just return a 
     "not implemented" message when a page is accessed).

    The next step is to provide proper implementations for the pages that display our library information
     (we'll look at implementing pages featuring forms to create, update, or delete information in later articles). 
     This includes updating the controller functions to fetch records using our models and defining templates 
     to display this information to users.

    Primero vamos a comenzar con un resumen / primer topic explicando cómo manegar operaciones asyncronas 
    en el controlador y cómo escribir templates usando PUG. Luego proveeremos implementación por 
    cada una de nuestras páginas principales de "solo lectura" con una breve explicación 
    de cualquier función nueva o especial que utilicen

    Al final de este articulo, tu deberias tener un buen entendimiento de final al final sobre como las rutas, funciones
    asincronicas, vistas y modelos funcionan en practica.

    ================= asynchronous flow control using async asincrono 
    Esto lo voy a detallar en el archivo.txt que está ../asynchronus flow control using async.txt 
    {
        El codigo de los controller para algunos de nuestras paginas de LocalLibrery dependeran de el resultado
        de multiples asynchronous request, los cuales requeriran de correr a la vez en una determinada orden en paralelo. 
        Para administrar el control de flujo y mostrar páginas cuando tengamos toda la información 
        requerida disponible, usaremos el popular node async modulo.

        Note: hay un numero de otras formas para manejar el comportamiento asincronico y el control de
        flujo en javascript, incluyendo funciones de lenguaje JavaScript relativamente recientes como Promises.

        async tiene un montón de metodos útiles ( chequea la documentación https://caolan.github.io/async/v3/docs.html ).
        Algunos e las más importantes son:

        - async.parallel() Ejecuta cualquier operaciones que deberia ser realizada en paralelo
        - async.series() para cuando necesitamos asegurar que la operaciones asincronica es realizada en series
        - async.waterfall() para operaciones que deberian correr en series, con cada operacion dependiendo
        de un resultado de procedentes operaciones

        === ¿Por qué es este necesario?
        Varios de los metodos que usamos en Express son asincronicos - usted especifica una operación para realizar, 
        pasando una callback. El metodo retorna inmediatamente, y la callback es invocada cuando la request operation es
        completada. Por la convencion en Express, las funciones callback pasan un valor de error en el primer
        parametro ( or null si es correcto) y el resultado de la funcion (if there are any) como the second parameter.
        A esto se refiere al utilizar la conexión de la basa de datos, básicamente necesita una forma de manejar los
        errores y los resultados.

        If a controller only needs to perform one asynchronous operation to get the information required to render 
        a page then the implementation is easy—we render the template in the callback. The code fragment below
        shows this for a function that renders the count of a model SomeModel (using the Mongoose countDocuments 
        method):

        {
            exports.some_model_count = function (req, res, next) {
            SomeModel.countDocuments(
                { a_model_field: "match_value" },
                function (err, count) {
                // Do something if there is an err.
                // …

                // On success, render the result by passing count into the render function (here, as the variable 'data').
                res.render("the_template", { data: count });
                }
            );
            };

        }


        What if you need to make multiple asynchronous queries, and you can't render the page until all the 
        operations have completed? A naive implementation could "daisy chain" the requests, kicking off 
        subsequent requests in the callback of a previous request, and rendering the response in the final callback.
         The problem with this approach is that our requests would have to be run in series, even though 
         it might be more efficient to run them in parallel. This could also result in complicated nested code, 
         commonly referred to as callback hell.

        A much better solution would be to execute all the requests in parallel and 
        then have a single callback that executes when all of the queries have completed. 
        This is the sort of flow operation that the Async module makes easy!

        ====  Asynchronous operations in parallel
        El metodo async.parallel() es usado para correr multiples operaciones asincronicas en paralelo.

        The first argument to async.parallel() is a collection of the asynchronous functions to run 
        (an array, object or other iterable). Each function is passed a callback(err, result) which it
         must call on completion with an error err (which can be null) and an optional results value.

         El segundo argumento opcional es una callback la cual correra cuando todas las funciones del primer 
         argumento esten completadas. El callback es invocado con un argumento de error y el
         resultado de la colección puede contener el resultado de las operaciones asincronas individuales. El
         resultado de la colección es del mismo tipo que el primer argumento (ej, si vos pasaste un array de funciones
         asincronas, el callback final invocará un array de resultados). Si cualquiera de las funciones 
         paralelas reportan un error, el callback es invocado prematuramente (con un error value)

         El ejemplo de abajo muestra como esto trabaja cuando le pasamos un objeto como el primer argumento. Como Puedes
         ver, el resultado esta retornando un objeto con los mimos properry name como la función original que fueron pasadas.

         {
            async.parallel(
            {
                 one(callback) {
                /* … */
                },
                two(callback) {
                /* … */
                },
                // …
                 something_else(callback) {
                /* … */
                },
            },
            // optional callback
            function (err, results) {
                // 'results' is now equal to: {one: 1, two: 2, …, something_else: some_value}
            }
            );

         }

        If you instead pass an array of functions as the first argument, the results will be an array 
        (the array order results will match the original order that the functions were declared—not the 
        order in which they completed).


        ====  Asynchronous operations in series
        El metodo async.series() es usado para correr multiples operaciones asincronas en secuencia, cuando
        la funcion subsecuente no depende del output de funciones anteriores. De declara esencialmente y se 
        comporta de la misma manera que async.parallel().

        {
            async.series(
            {
                one(callback) {
                // …
                },
                two(callback) {
                // …
                },
                // …
                something_else(callback) {
                // …
                },
            },
            // optional callback after the last asynchronous function completes.
            function (err, results) {
                // 'results' is now equal to: {one: 1, two: 2, /* …, */ something_else: some_value}
            }
            );

        }

        Nota: La especificación del idioma ECMAScript establece que el orden de enumeración de un objeto no está 
        definido, por lo que es posible que las funciones no se llamen en el mismo orden en que las especifica 
        en todas las plataformas. Si el orden es realmente importante, debe pasar una matriz en lugar de un 
        objeto, como se muestra a continuación.

        {
            async.series(
            [
                function (callback) {
                // do some stuff …
                callback(null, "one");
                },
                function (callback) {
                // do some more stuff …
                callback(null, "two");
                },
            ],
            // optional callback
            function (err, results) {
                // results is now equal to ['one', 'two']
            }
            );
        }

        ======== Operaciones asincronincas dependientes en series 
        El metodo async.waterfall() es usado para correr multiples operaciones asincronas en secuencia
        cuando una operacion depende de un resultado de una operación previa.

        El callback invocado de cada funcion asincronica contiene contiene null como el primer argumento
        y da como resultado en argumentos subsecuentes. Cada función en la serie toma el resultado de su callback 
        previa como el primer parametro, y luego una función callback. CUnado todas las operaciones son completadas,
        el callback final es invocado con el resultado de la última operación. La forma en la que esto trabaja
        es mas clara cuando consideras el codigo de debajo (este ejemplo es de la focumentación de async)

        {
            async.waterfall(
            [
                function (callback) {
                callback(null, "one", "two");
                },
                function (arg1, arg2, callback) {
                // arg1 now equals 'one' and arg2 now equals 'two'
                callback(null, "three");
                },
                function (arg1, callback) {
                // arg1 now equals 'three'
                callback(null, "done");
                },
            ],
            function (err, result) {
                // result now equals 'done'
            }
            );

        }

        La diferencia entre el asynchronous de series y el dependent asynchronus series es que el segundo
        toma los resultados de los callbacks anteriores.

        Para instalar el modulo sólo tenes que pondremos
        npm install async
    }

    ====================== Template primer
    Una template es un atchivo de texto que define una estructura o el diseño (layout) de un archivo output, con placeholder
    usados para repsentear donde la data será inserdafa cuando el templeate es renderizado (in Express, las templates
    son referidas como views).

    ==== Express template choices
    Express es usado con varios template rendering engines difernetes. En este tutorial usaremos PUG (anteriormente conocido como Jade)
    para nuestras templates. Este es el lenguaje de templates más conocido de Node, y se describe a si mismo como 
    "limpio, sencible a espacios en blanco sintaxts para escribir HTML y con una gran influencia de Haml.

    Diferentes elnguajes usan diferentes enfoques para definir vistas y hacer placehorder para la data - algunos usan
    HTML para definir el diseño mientras otros usan un diferente formate de margen el cual puede ser 
    transpilado a HTML. Pug es del seugndo tipo, este usa una representación de HTML donde la primera palabra en cualquier
    linea usualmente represeta un HTML element, y la identación en subsecuentes lineas
    es usado para representar una anidacion (hijos). El resultado de la definición de la pag se traslada directamente a HTML,
    pero es más consio y posiblemente más facil de leer.

    Note: La desventaja (downside) de usar pug es que es sensible a la identación y a los espacios en blanco ( si añades
    un espacio extra en el espacio equivocado tu puedes obtener un codigo de error inutil). Una vez tu tienes tus templates
    en lugar, a su vez, estos son muy faciles de leer y mantener.

    ======== Template configuration
    The LocalLibrary fue configuarada para usar PUG cuando fue creado el esqueleto del sitio web. Tu deberías
    ver el modulo pug incluido en tu dependencia en tu website's package.json file, y la iguiente configuracion en app.js file.
    La configuración nos dirá que usaremos pug como una view engine, y esto le dirá a Express que busque templeates in view subdirectory.

    {
        // View engine setup
    app.set("views", path.join(__dirname, "views"));
    app.set("view engine", "pug");

    }

    If you look in the views directory you will see the .pug files for the project's 
    default views. These include the view for the home page (index.pug) and base template (layout.pug) that we will need to replace with our own content.
        /express-locallibrary-tutorial  //the project root
        /views
        error.pug
        index.pug
        layout.pug

    ============ Template syntax

    https://pugjs.org/language/plain-text.html
    El ejemplo de archivo template de abajo muestra (show off) muchas de las características más útiles de Pug's.

    The first thing to notice is that the file maps the structure of a typical HTML file, with the first word in (almost)
    every line being an HTML element, and indentation being used to indicate nested elements. So for example, the body 
    element is inside an html element, and paragraph elements (p) are within the body element, etc. Non-nested elements
    (e.g. individual paragraphs) are on separate lines.
    {
        doctype html
    html(lang="en")
    head
        title= title
        script(type='text/javascript').
    body
        h1= title

        p This is a line with #[em some emphasis] and #[strong strong text] markup.
        p This line has un-escaped data: !{'<em> is emphasized</em>'} and escaped data: #{'<em> is not emphasized</em>'}.
        | This line follows on.
        p= 'Evaluated and <em>escaped expression</em>:' + title

        <!-- You can add HTML comments directly -->
        // You can add single line JavaScript comments and they are generated to HTML comments
        //- Introducing a single line JavaScript comment with "//-" ensures the comment isn't rendered to HTML

        p A line with a link
        a(href='/catalog/authors') Some link text
        |  and some extra text.

        #container.col
        if title
            p A variable named "title" exists.
        else
            p A variable named "title" does not exist.
        p.
            Pug is a terse and simple template language with a
            strong focus on performance and powerful features.

        h2 Generate a list

        ul
        each val in [1, 2, 3, 4, 5]
            li= val

    }

    Los elemntos atributos  (atributos a secas xdd) son definidos con parentessis después de sus elemento asociado. 
    Dentro de los paréntesis, los atributos se definen en listas separadas por comas o espacios en blanco de los 
    pares de nombres de atributos y valores de atributos, por ejemplo:
    {
        script(type='text/javascript'), link(rel='stylesheet', href='/stylesheets/style.css')
        meta(name='viewport' content='width=device-width initial-scale=1')
    }

    Si la etiqueta esta seguida por un signo de igual (=), el siguiente texto es tratado como una expresión html.
    {
        h1= title
        p= 'Evaluated and <em>escaped expression</em>:' + title

    }
    Si no tiene un signo de igual, este contenido es tratado como n texto explicativo. Dentro de este podes
    aplicar escaped y unescaped data usando #{} and !{} syntaxis respectivamente, como mostramos abajo.
    {
        p This is a line with #[em some emphasis] and #[strong strong text] markup.
        p This line has an un-escaped string: !{'<em> is emphasized</em>'}, an escaped string: #{'<em> is not emphasized</em>'}, and escaped variables: #{title}.
 
    }


    Nota: casi siempre querrá escapar de los datos de los usuarios (a través de la sintaxis #{}). Los datos en los 
    que se puede confiar (por ejemplo, recuentos de registros generados, etc.) se pueden mostrar sin escapar de 
    los valores.

    Tu también puedes usar ('|') para comenzar una linea indicando "texto plano". El texto plano es, cualquier
    coigo o texto que debería ir, sin procesar, directamtne a renderizarse como HTML. Estos son útiles en diferentes situaciones.
    {
        a(href='http://someurl/') Link text
        | Plain text

    }

    Pugs te permite realizar conficionales utilizando if, else, else if y unless, for ejemplo: 
    {
        if title
            p A variable named "title" exists
        else
            p A variable named "title" does not exist

    }

    Tambien puede hacer iteraciones utilizando each.in o while syntax.  In the code fragment below we've 
    looped through an array to display a list of variables (note the use of the 'li=' to evaluate the 
    "val" as a variable below. The value you iterate across can also be passed into the template as a 
    variable!

    {
        ul
            each val in [1, 2, 3, 4, 5]
        li= val

    }

    La syntaxis también soporta comentarios ( que seran renderizados en el output o no, como decis)
    creando bloques reusables de codigo, testamentos de cado y otras características. Para más inforamción,
    poder ir a https://pugjs.org/api/getting-started.html

    ==== Extending templates
    Al rededor del sitio, es usual que todas las paginas tgengan una estructura en común, incluyendo un standar de HTML 
    para el head, footer, navigaton,etc. 

    En lugar de (rahter than ) forzar a los desarrolladores a duplicar este "modelo" en cada página,
    pugs permite declarar una base de templeats y extenderlo, reemplazando sólo las partes
    que son diferentes para cada pagina específica.

    For ejemplo, la base del template layout.pug creada en el esqueleto del proyecto es como esta:
    {
        doctype html
        html
        head
            title= title
            link(rel='stylesheet', href='/stylesheets/style.css')
        body
            block content

    }
    La etiqueta block es usada para marcar secciones de contenido que tal vez reemplacemos en derivadas templeates(si 
    el blockno se redefine, se usa su implementación en la clase base)

    El default index.pug(creado en nuestro projecto) muestra como nosotros anulamos la base del template.
    La etiqueta extends tag identifica una base de template que utilizaremos, y luego usamos block section_name
    para inicar el nuevo contenido en la sección que será anulado.

    {
        extends layout

        block content
        h1= title
        p Welcome to #{title}

    }

    ================== LocalLibrary base template
    Ahora vamos a entender como se extienden las template sutilziando PUG, vamos a crear una base de    
    template para nuestro projecto. Este tendrá una sidebar con links de las paginas que vamos a crear a lo largo 
    del los articulos del tutuorial (ej desplegando y creando libros, generos, autores, etc) y el contenido main 
    sera invalidado en cada una de nuestras paginas inividuales.

    Abrimos views/layouts.pug y reemplazamos el contenido existente por el código de abajo: 
    {

        doctype html
        html(lang='en')
        head
            title= title
            meta(charset='utf-8')
            meta(name='viewport', content='width=device-width, initial-scale=1')
            link(rel="stylesheet", href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css", integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z", crossorigin="anonymous")
            script(src="https://code.jquery.com/jquery-3.5.1.slim.min.js", integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj", crossorigin="anonymous")
            script(src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js", integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV", crossorigin="anonymous")
            link(rel='stylesheet', href='/stylesheets/style.css')
        body
            div(class='container-fluid')
            div(class='row')
                div(class='col-sm-2')
                block sidebar
                    ul(class='sidebar-nav')
                    li
                        a(href='/catalog') Home
                    li
                        a(href='/catalog/books') All books
                    li
                        a(href='/catalog/authors') All authors
                    li
                        a(href='/catalog/genres') All genres
                    li
                        a(href='/catalog/bookinstances') All book-instances
                    li
                        hr
                    li
                        a(href='/catalog/author/create') Create new author
                    li
                        a(href='/catalog/genre/create') Create new genre
                    li
                        a(href='/catalog/book/create') Create new book
                    li
                        a(href='/catalog/bookinstance/create') Create new book instance (copy)

                div(class='col-sm-10')
                block content

    }

    La templeates usa (e inclute) JavaScript y CSS de bootstrap para mejorar ( impove ) la vista y 
    la presentación de la página html. Usando bootstrap o otro clent-side ( lado del cliente ) web framework
    es un camino rapido para crear una pagina atractiva que tiene una buena escala en diferentes navegadores,
    y tambien nos permite tratar con la presentacion de la pagina sin tener que entrar dentro
    de ningun detalle, nosotros sólo queremos centrarnos en el server-side (espacio del servidor) en este código

    La base de datos hace referencia a un esstilo css local que provee
    un poco de información adicional de css, este en public/stylesheets/style.css

    {
        .sidebar-nav {
        margin-top: 20px;
        padding: 0;
        list-style: none;
        }

    }

    Ahora tenemos una pagina con una sidebar. En la sig sección la usaremos para definir paginas individuales

    =================== Home Page
    The first page we'll create will be the website home page, which is accessible from either the site ('/') 
    or catalog (catalog/) root. This will display some static text describing the site, along with dynamically
     calculated "counts" of different record types in the database.

    We've already created a route for the home page. In order to complete the page we need to update our controller 
    function to fetch "counts" of records from the database, and create a view (template) that we can use to render the page.

    ===== Route
    Creamos nuestro index en tutoriales previos. Para recordar, todas las funciones de rutas estan definidas en routes/catalog

    {
        // GET catalog home page.
        router.get("/", book_controller.index); //This actually maps to /catalog/ because we import the route with a /catalog prefix

    }

    Donde el callback llama a la función (book_controller.index) el cual es definido en /controller/bookController.js
    {
        exports.index = (req, res, next) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };

    }
    En este controlador vamos a extender la infroacmión de nuestro modelo y la renderizaremos utilizando la view


    ==== Controller
    The index controller function needs to fetch information about how many Book, BookInstance, available BookInstance,
    Author, and Genre records we have in the database, render this data in a template to create an HTML page, 
    and then return it in an HTTP response.

    {
        Note: We use the countDocuments() method to get the number of instances of each model. This is called on a model,
        with an optional set of conditions to match against in the first argument, and a callback in the second argument 
        (as discussed in Using a Database (with Mongoose), and you can also return a Query and then execute it with a 
        callback later). The callback will be invoked when the database returns the count, with an error value as the
        first parameter (or null) and the count of documents as the second parameter (or null if there was an error) .

        {
            SomeModel.countDocuments({ a_model_field: "match_value" }, (err, count) => {
            // Do something if there is an err
            // Do something with the count if there was no error
            });

        }
    }
    
    Abrimos /controllers/bookController.js. Cerca del top de nuestro archivo exportamos la función index
    {
        const Book = require("../models/book");

        exports.index = (req, res, next) => {
        res.send("NOT IMPLEMENTED: Site Home Page");
        };
    }

    y Ahora remplazamos todo el codigo de arriba con el siguiente fragmento. Lo primero es importart (require()) todos 
    los modelos. Los encesitamos porque vamos a usarlos para contar los documentos. También importanmos
    el modulo async (como discutimos previamente en Asynchronous flow control using async)

    {
        const Book = require("../models/book");
        const Author = require("../models/author");
        const Genre = require("../models/genre");
        const BookInstance = require("../models/bookinstance");

        const async = require("async");

        exports.index = (req, res) => {
        async.parallel(
            {
            book_count(callback) {
                Book.countDocuments({}, callback); // Pass an empty object as match condition to find all documents of this collection
            },
            book_instance_count(callback) {
                BookInstance.countDocuments({}, callback);
            },
            book_instance_available_count(callback) {
                BookInstance.countDocuments({ status: "Available" }, callback);
            },
            author_count(callback) {
                Author.countDocuments({}, callback);
            },
            genre_count(callback) {
                Genre.countDocuments({}, callback);
            },
            },
            (err, results) => {
            res.render("index", {
                title: "Local Library Home",
                error: err,
                data: results,
            });
            }
        );
        };

    }

    Al método async.parallel() se le pasa un objeto con funciones para obtener los recuentos de cada 
    uno de nuestros modelos. Todas estas funciones se inician al mismo tiempo. Cuando todos 
    han completado, se invoca la devolución de llamada final con los recuentos en el parámetro 
    de resultados (o un error).

    Si todo estrá bien, el callback del segundo parametro se ejecuta , especificando la vista llamada "Index"
    y un objeto que contiene la data que sera insertada dentro de este ( este incluyeu un objeto de resultado que
    contiene nuestras cuentas del modelo). La data es suministrada ( supplied ) como pares clave-valor, y puede ser
    accesible en nuestra templete utilizando las keys.

    Nota: La función de devolución de llamada de async.parallel() anterior es un poco inusual en 
    el sentido de que representamos la página haya o no un error (normalmente, puede usar una ruta
     de ejecución separada para manejar la visualización de errores). Tipo renderizas otra template
     para manejar estos errores.

    ===== View
    Abrimos /views/layouts/index.pug y reemplazamos el contenido con el texto de debajo
    {
        extends layout

        block content
        h1= title
        p Welcome to #[em LocalLibrary], a very basic Express website developed as a tutorial example on the Mozilla Developer Network.

        h1 Dynamic content

        if error
            p Error getting dynamic content.
        else
            p The library has the following record counts:

            ul
            li #[strong Books:] !{data.book_count} // esto podría ser un b, no necesitariamente strong, basicamente lo
            que hace #[es el evitar pasar de linea, es como una linea dentro de otra, ya que recordemos, cada etiqueta se usa en una linea]
            li #[strong Copies:] !{data.book_instance_count}
            li #[strong Copies available:] !{data.book_instance_available_count} // Y esto es para poner la data noma,tranqui
            li #[strong Authors:] !{data.author_count}
            li #[strong Genres:] !{data.genre_count}

    }

    La vista es sencilla (straightforward - derecha hacia adelante). Extenedemos la layout.pug, primordiando el block 
    llamado "content". The first h1 heading will be the escaped text for the title variable that was passed into 
    the render() function—note the use of the 'h1=' so that the following text is treated as a 
    JavaScript expression. We then include a paragraph introducing the LocalLibrary.

    Under the Dynamic content heading we check whether the error variable passed in from the render() 
    function has been defined. If so, we note the error. If not, we get and list the number of copies 
    of each model from the data variable

    Nota: No escapamos de los valores de conteo (es decir, usamos la sintaxis !{}) porque se calculan 
    los valores de conteo. Si la información fue proporcionada por los usuarios finales, escaparíamos 
    de la variable para mostrarla.


    ====================== Book list Page
    Ahora vamos a implementar nuestra llist page. Esta pagina necesita desplegar una lista de todos los libros en
    la base de datos al rededor de su author, con cada titulo siendo un hyperlink asociado a los book detail page.

    ==== Controller
    The book list controller function needs to get a list of all Book objects in the database, sort them, 
    and then pass these to the template for rendering.

    Open /controllers/bookController.js. Find the exported book_list() controller method and replace it 
    with the following code.

    {
        // Display list of all Books.
        exports.book_list = function (req, res, next) {
        Book.find({}, "title author")
            .sort({ title: 1 })
            .populate("author")
            .exec(function (err, list_books) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("book_list", { title: "Book List", book_list: list_books });
            });
        };

    }

    El metodo utilizando en este modelo find() function devuelve todos los Book object, seleccionando 
    para devolver sólo title and author ya que nosotros no necesitamos otros archivos (it will also return the
    _id and virtual fiels) y entonces ordena (sorts) los resultados con el titulo alfabeticamente usando el metodo sort().
    Aqui nosotros llamamdo populated() en Libro, especialmente en el apartado de author - este reemplazará lo almacenado en
    author id con todos los detalles del author.

    sobre el existo, el callback pasará a una peticion para renderizar book_list.pug template, pasando el titulo
    y la lista de libros (lista de libros con autores) como variables

    === VIEW 
    Por lo que viendo lo de antes, creamos views/book_list.pug y copiamos el texto de debajo

    {
        extends layout

        block content
        h1= title

        ul
            each book in book_list
            li
                a(href=book.url) #{book.title}
                |  (#{book.author.name})

            else
            li There are no books.

    }

    The view extends the layout.pug base template and overrides the block named 'content'. 
    It displays the title we passed in from the controller (via the render() method) and iterates 
    through the book_list variable using the each-in-else syntax. A list item is created for each 
    book displaying the book title as a link to the book's detail page followed by the author name. 
    If there are no books in the book_list then the else clause is executed, and displays the text 
    'There are no books'.

    {
        Note: We use book.url to provide the link to the detail record for each book (we've implemented 
        this route, but not the page yet). This is a virtual property of the Book model which uses 
        the model instance's _id field to produce a unique URL path.
    }

    Of interest here is that each book is defined as two lines, using 
    the pipe for the second line. This approach is needed because if the 
    author name were on the previous line then it would be part of the hyperlink.

    ========== Bookinstance list page
    Ahora vamos a implementar nuestra list de todas las copias de los libros (bookinstance) en la libreria. Esta pagina
    necesita incluir el titulo del libro, asociado a cada BookInstance ( linkeando esto a su pagina de detalles) a lo
    largo con otra información en bookinstance model, incluyendo status, imprintm y la id unica de cada copia. 
    The unique id text deberia estar asociadao con la BookInstance detail page.

    === Controller
    The bookInstance list controller funcion necesito obtener una lsita de todas las book instances, populando
    la información asociada al libro, y esta pasa una lista a la tempalte para renderizarlo.

    Abrimos /controllers/bookinstanceController.js. Y rellenamos la exportación bookinstance_list() controlador metodo y 
    reemplazamos esto con el siguiente código: 

    {
        // Display list of all BookInstances.
        exports.bookinstance_list = function (req, res, next) {
        BookInstance.find()
            .populate("book")
            .exec(function (err, list_bookinstances) {
            if (err) {
                return next(err);
            }
            // Successful, so render
            res.render("bookinstance_list", {
                title: "Book Instance List",
                bookinstance_list: list_bookinstances,
            });
            });
        };

    }
    El metodo usa find() function para retornar todas las bookInstances. luego conecta en cadena una 
    llamada a populate() con el campo de libro; esto reemplazará la identificación del libro almacenada 
    para cada BookInstance con un documento de libro completo.

    On success, the callback passed to the query renders the bookinstance_list(.pug) 
    template, passing the title and bookinstance_list as variables.

    ==== VIEW 
    Creamos /Views/bookinstance_list.pug y copiamos el texto de abajo
    {
        extends layout

        block content
        h1= title

        ul
            each val in bookinstance_list
            li
                a(href=val.url) #{val.book.title} : #{val.imprint} -
                if val.status=='Available'
                span.text-success #{val.status}
                else if val.status=='Maintenance'
                span.text-danger #{val.status}
                else
                span.text-warning #{val.status}
                if val.status!='Available'
                span  (Due: #{val.due_back} )

            else
            li There are no book copies in this library.

    }

    Esta vista es casi lo mismo que las otras. Esta se extiende del layout, teemplazando content block, 
    despliega un titulo pasado por el controlador, e itera a travez de todas las copias de los libros 
    en bookInstance_list. Para cada copia el despliega su status (con color ) y si el libro no esta
    disponible, este returna el dato, de cuando volverá. Una nueva característica es introducida- podemosusar una 
    identación con un punto ( . ) luego de la etiqueta para asignar una clase. Entonces span.text-success puede ser
    compilado com <span class="text-success">, este también podría ser escrico como span(class="text-succes")


    ========= DATE FORMATTTING USING LUXON
    El renderizado po defecto de los dates de las bookinsntaces es muy feo: 
    " (Due: Sat Dec 31 2022 15:17:05 GMT-0300 (hora estándar de Argentina) )". 
    En esta sección vamos a ver como puedes actualizar bookinstance list page de la sección previa
    para preentar due_Date field en un formato más amigable: Dec 31th, 2022.

    Para accercarse ( approach ) usaremos para crear una propiedad virtual en nuestro modelo de bookinstance, que nos
    devolverá la fecha formateada :D . Haremos que el formato actual cambie usando luxon, una poderosa, moderna 
    y amigable libreria para pasar, validar manipular, formatear y localizar datos.

    Nota: es posible usar luxon para formatear las string directamente en nuestras templates de pug, o 
    podemos formatear las string de varioas otras formas. Utilizando una propiedad virtual, nos permite
    obtener esa data formateada de exactamente la misma forma en la que obtenemos due_date actualmente.

    Note: este tutorial previamente usó moment library para formatear la libreria. Nos mudamos a luxon porque
    moment se ha declarado "legado" (legacy). Luxon es uno de los moment project0s main recommendations para
    una nueva libreria alternativa.

    ==== Install Luxon
    Ponemos el siguiente comando en la terminar del proyecto:
    npm install luxon

    ==== Creamos una propiedad virtual
    1. abrimos ./models/bookinstance.js
    2. en la parte de arriba de la pagina, importamos luxon.

        const { dateTime } = require("luxon");

    Añadimos la propiedad virtual de due_back_formated justo después de la propiedad URL
    {
        BookInstanceSchema.virtual("due_back_formatted").get(function () {
        return DateTime.fromJSDate(this.due_back).toLocaleString(DateTime.DATE_MED);
        });

    }

    Note: Luxon puede importar string de varios formatos y exportar ambos predefinidos y free.form formats.
    En este caso nosotros usamos formJSDate() para importar un dato string de js Y toLocalSstring() para
    lanzar el dato en date_med formato en ingles. Oct 6th,2022. Para más información acerca de los formates y
    los datos de string, mirar la documentación de string en: https://github.com/moment/luxon/blob/master/docs/formatting.md#formatting

    == Update the view
    Abrimos /view/bookinstance_list.pug y reemplazamos due_back por due_back_formatted 
    {
        if val.status != 'Available'
        //span  (Due: #{val.due_back} )
        span  (Due: #{val.due_back_formatted} )

    }

    ======================== Author list page and Genre list page Challenge
    The author list page needs to displaya a list of all authors in the database, witheach author
    name linked to its associated author detail page. The date of birth and date of death should be listed
    after the name on the same line.

    === Controller
    The author list controller function needs to get a list of all Author instances, 
    and then pass these to the template for rendering.

    Open /controllers/authorController.js. Find the exported author_list() controller
    method near the top of the file and replace it with the following code.

    {
            // Display list of all Authors.
        exports.author_list = function (req, res, next) {
        Author.find()
            .sort([["family_name", "ascending"]])
            .exec(function (err, list_authors) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("author_list", {
                title: "Author List",
                author_list: list_authors,
            });
            });
        };

    }

    The method uses the model's find(), sort() and exec() functions to return all 
    Author objects sorted by family_name in alphabetic order. The callback passed
    to the exec() method is called with any errors (or null) as the first parameter,
    or a list of all authors on success. If there is an error it calls the next middleware 
    function with the error value, and if not it renders the author_list(.pug) template, 
    passing the page title and the list of authors (author_list).


    ==== VIEW
    Creamos /views/author_list.pug y ponemos el conteido de debajo 
    {
        extends layout

        block content
        h1= title

        ul
            each author in author_list
            li
                a(href=author.url) #{author.name}
                |  (#{author.date_of_birth} - #{author.date_of_death})

            else
                li There are no authors.



    }

    ========== Genre list page --- challenge!
    En esta seccion tu deberas implementar tu propia genre list page. La pagina deberia desplegar una lista
    de todos los generos de la base de datos, con cada genero linkeado a su associated details page. 

    Para esto tenemos que modificar el genre_controller, el export.genre_list con el sig codigo: 
    {
        // Display list of all Genre.
        exports.genre_list = function (req, res, next) {
        Genre.find()
            .sort([["name", "ascending"]]) 
            .exec(function (err, list_genre) {
            if (err) {
                return next(err);
            }
            //Successful, so render
            res.render("genre_list", {
                title: "Genre List",
                genre_list: list_genre,
            });
        });
        };

    }

    Este es practicamente lo mismo que hicimos con author
    Luego creamos la view genre_list.pug y ponemos lo siguiente: 
    {
        extends layout

        block content
        h1= title

        ul
            each genre in genre_list
            li
                a(href=genre.url) #{genre.name}

            else
            li There are no genres.  
    }


    ================== Genre Detail Page
    El genere detail pagina necesita la información en particual de cada instancia de genero, usando el
    _id generado automáticamente. la pagina debería mostrar una lista de generos y una lista de todos los
    libros con el género de la pag

    ==== Controller
    abrimos /Controllers/genreController.js e importamos async y el modulo book en el top del archivo
    {
        const Book = require("../models/book");
        const async = require("async");

    }

    Rellenamos la exportación genre_details() controller method y ponemos el siguiente condigo 

    {
        // Display detail page for a specific Genre.
        exports.genre_detail = (req, res, next) => {
        async.parallel(
            {
            genre(callback) {
                Genre.findById(req.params.id).exec(callback);
            },

            genre_books(callback) {
                Book.find({ genre: req.params.id }).exec(callback);
            },
            },
            (err, results) => {
            if (err) {
                return next(err);
            }
            if (results.genre == null) {
                // No results.
                const err = new Error("Genre not found");
                err.status = 404;
                return next(err);
            }
            // Successful, so render
            res.render("genre_detail", {
                title: "Genre Detail",
                genre: results.genre,
                genre_books: results.genre_books,
            });
            }
        );
        };

    }

    El metodo usado es async.parallel() para peticiones de genero name y es asociado con libros en paralelo, con el
    callback renderizando la pagina cuando (if) ambas request son completadas.

    El ID de la request registro es codigicadod de el final de la UTL y extraida automáticamente de la definicion
    de ruta (genre/:id). La id es accesible dentro del controllador utilizando req.params.id. Esto es
    usado con genre.findById() para obtener el genero en cuestion. Esto también es usado para obtener el objeto Book
    el cual tiene un genero ID en su campo de genero: Book.find({'genre': req.params.id})


    Note: si el genero no existe en la base de datos ( p.e si está elimindo) este finById() retornará exito pero no 
    resultados. En este caso, nosotros podemos desplegar un "not found" page, para crear un objeto de error y pasar 
    al siguiente middleware function en la cadena.
    {
        if (results.genre == null) {
        // No results.
        const err = new Error("Genre not found");
        err.status = 404;
        return next(err);
        }

    }
    El mensaje  será propagado a trabez de nuestro codigo manejador de errores ( este fue generado cuando nosotros
    generamos el esqueleto de la app - para más información mira: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction#handling_errors)

    Para renderizar la vista genre_details y que este pase variables para el titulo, genero y la lista de libros de
    este genero (genre_books)

    === VIEW
    Creamos genre_details.pug en views y ponemos el siguiente código:
    {
        extends layout

        block content

        h1 Genre: #{genre.name}

        div(style='margin-left:20px;margin-top:20px')

            h4 Books

            dl
            each book in genre_books
                dt
                a(href=book.url) #{book.title}
                dd #{book.summary}

            else
                p This genre has no books

    }
    Esta vista es muy similar a todas las otras templates. La principal diferencia es que esta no usa un titulo 
    pasado en el primer encabedazo ( pero esta si es usado en la subyacente layout.pug template para asignar
    el titulo de la página)

 ]